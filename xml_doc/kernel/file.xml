<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>1996</year><year>2011</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      The contents of this file are subject to the Erlang Public License,
      Version 1.1, (the "License"); you may not use this file except in
      compliance with the License. You should have received a copy of the
      Erlang Public License along with this software. If not, it can be
      retrieved online at http://www.erlang.org/.

      Software distributed under the License is distributed on an "AS IS"
      basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
      the License for the specific language governing rights and limitations
      under the License.

    </legalnotice>

    <title>file</title>
    <prepared></prepared>
    <docno></docno>
    <date></date>
    <rev></rev>
  </header>
  <module>file</module>
  <modulesummary>File Interface Module</modulesummary>
  <description>
    <p>The module <c>file</c> provides an interface to the file system.</p>
    <p_zh><c>file</c>模块提供了一个文件系统接口.</p_zh>
    <p>On operating systems with thread support, it is possible to let
      file operations be performed in threads of their own, allowing
      other Erlang processes to continue executing in parallel with
      the file operations. See the command line flag
      <c>+A</c> in <seealso marker="erts:erl">erl(1)</seealso>.</p>
    <p_zh>在支持线程的操作系统上, 可能会让文件操作在它们自己的线程上进行, 从而使得Erlang的进程能够与文件系统并行的执行. 参阅<seealso marker="erts:erl">erl(1)</seealso>中的命令行标记<c>+A</c> .</p_zh>

    <p>The Erlang VM supports file names in Unicode to a limited
    extent.  Depending on how the VM is started (with the parameter
    <c>+fnu</c> or <c>+fnl</c>), file names given can contain
    characters > 255 and the VM system will convert file names
    back and forth to the native file name encoding.</p>

    <p_zh>Erlang的虚拟机支持Unicode编码的限制长度的文件名字.  这取决于虚拟机是如何启动的（以<c>+fnu</c> 或 <c>+fnl</c>作为参数),  文件名可以包含多于255个字符并且虚拟机系统将会把文件名转换成本地文件名编码方式.</p_zh>

    <p>The default behavior for Unicode character translation depends
    on to what extent the underlying OS/filesystem enforces consistent
    naming. On OSes where all file names are ensured to be in one or
    another encoding, Unicode is the default (currently this holds for
    Windows and MacOSX). On OSes with completely transparent file
    naming (i.e. all Unixes except MacOSX), ISO-latin-1 file naming is
    the default. The reason for the ISO-latin-1 default is that
    file names are not guaranteed to be possible to interpret according to
    the Unicode encoding expected (i.e. UTF-8), and file names that
    cannot be decoded will only be accessible by using &quot;raw
    file names&quot;, in other word file names given as binaries.</p>

   <p_zh>Unicode字符转换的默认行为取决于底层系统或文件系统对文件名长度的限制. 在那些所有文件名确定可以是一个或其它编码系统的系统上, Unicode编码是默认的(目前Windows和MacOSX是这样的）. 在文件名是完全透明的系统上(例如除了MacOSX以外所有Unix系统), ISO-latin-1的文件名编码是默认的. 使用ISO-latin-1作为默认编码的原因是文件名不能保证可以根据所期望的Unicode编码(例如UTF-8)进行解释, 并且那写不能解码的文件名将只能会通过使用&quot;原始文件名&quot;, 也就是说文件名以二进制的形式给出.</p_zh>
 
    <p>As file names are traditionally not binaries in Erlang,
    applications that need to handle raw file names need to be
    converted, why the Unicode mode for file names is not default on
    systems having completely transparent file naming.</p>

    <p_zh>因为在Erlang中文件名通常不是二进制形式, 所以在处理原始文件名的应用中需要进行转换, 这也就是为什么在拥有完全透明的文件名的系统上Unicode模式的文件名不是默认的原因.</p_zh>

    <note>
      <p>As of R14B01, the most basic file handling modules
      (<c>file</c>, <c>prim_file</c>, <c>filelib</c> and
      <c>filename</c>) accept raw file names, but the rest of OTP is not
      guaranteed to handle them, why Unicode file naming on systems
      where it is not default is still considered experimental.</p>

      <p_zh>在R14B01中, 最基本的文件处理模块(<c>file</c>, <c>prim_file</c>, <c>filelib</c> 和 <c>filename</c>) 都能够接受原始文件名, 但是不能保证OTP其他部分也能处理它们, 这就是为什么Unicode编码的文件名在[TODO] 系统why Unicode file naming on systems where it is not default is still considered experimental.</p_zh>
    </note>

    <p>Raw file names is a new feature in OTP R14B01, which allows the
    user to supply completely uninterpreted file names to the
    underlying OS/filesystem. They are supplied as binaries, where it
    is up to the user to supply a correct encoding for the
    environment. The function <c>file:native_name_encoding()</c> can
    be used to check what encoding the VM is working in. If the
    function returns <c>latin1</c> file names are not in any way
    converted to Unicode, if it is <c>utf8</c>, raw file names should
    be encoded as UTF-8 if they are to follow the convention of the VM
    (and usually the convention of the OS as well). Using raw
    file names is useful if you have a filesystem with inconsistent
    file naming, where some files are named in UTF-8 encoding while
    others are not. A file:list_dir on such mixed file name systems
    when the VM is in Unicode file name mode might return file names as
    raw binaries as they cannot be interpreted as Unicode
    file names. Raw file names can also be used to give UTF-8 encoded
    file names even though the VM is not started in Unicode file name
    translation mode.</p>

    <p_zh>原始文件名是R14B01的一个新特性，这样就允许用户给底层的系统或文件系统提供根本未被翻译的文件名. 它们被以二进制的形式提供, [TODO]根据用户为环境提供正确的编码方式. 函数<c>file:native_name_encoding()</c>可以用来检测虚拟机是工作在什么编码环境下. 如果该函数返回<c>latin1</c>, 文件名将不会被以任何方式转换成Unicode, 如果返回<c>utf8</c>, 那么原始文件名应该被编码成UTF-8
    be encoded as UTF-8 if they are to follow the convention of the VM
    (and usually the convention of the OS as well). Using raw
    file names is useful if you have a filesystem with inconsistent
    file naming, where some files are named in UTF-8 encoding while
    others are not. A file:list_dir on such mixed file name systems
    when the VM is in Unicode file name mode might return file names as
    raw binaries as they cannot be interpreted as Unicode
    file names. Raw file names can also be used to give UTF-8 encoded
    file names even though the VM is not started in Unicode file name
    translation mode.</p_zh>

    <p>Note that on Windows, <c>file:native_name_encoding()</c>
    returns <c>utf8</c> per default, which is the format for raw
    file names even on Windows, although the underlying OS specific
    code works in a limited version of little endian UTF16. As far as
    the Erlang programmer is concerned, Windows native Unicode format
    is UTF-8...</p>

    <p_zh>注意在Windows系统上, <c>file:native_name_encoding()</c> 默认返回<c>utf8</c>, 即便原始文件名格式是在Windows系统上
    , 尽管底层的操作系统特有代码在一个限制的小端UTF16的版本. As far as
    the Erlang programmer is concerned, Windows native Unicode format
    is UTF-8...</p_zh>
  </description>

  <datatypes>
    <datatype>
      <name name="deep_list"/>
    </datatype>
    <datatype>
      <name name="fd"/>
    </datatype>
    <datatype>
      <name name="filename"/>
    </datatype>
    <datatype>
      <name name="io_device"/>
      <desc>
        <p>As returned by
          <seealso marker="#open/2">file:open/2</seealso>,
          a process handling IO protocols.</p>
      </desc>
    </datatype>
    <datatype>
      <name name="name"/>
      <desc>
        <p>If VM is in Unicode filename mode, <c>string()</c> and <c>char()</c>
          are allowed to be > 255.
          <c><anno>RawFilename</anno></c> is a filename not subject to
          Unicode translation,
          meaning that it can contain characters not conforming to
          the Unicode encoding expected from the filesystem
          (i.e. non-UTF-8 characters although the VM is started
          in Unicode filename mode).
        </p>
      </desc>
    </datatype>
    <datatype>
      <name name="posix"/>
      <desc>
        <p>An atom which is named from the POSIX error codes used in
          Unix, and in the runtime libraries of most C compilers.</p>
      </desc>
    </datatype>
    <datatype>
      <name name="date_time"/>
      <desc>
        <p>Must denote a valid date and time.</p>
      </desc>
    </datatype>
    <datatype>
      <name name="file_info"/>
    </datatype>
    <datatype>
      <name name="location"/>
    </datatype>
    <datatype>
      <name name="mode"/>
    </datatype>
    <datatype>
      <name name="file_info_option"/>
    </datatype>
    <datatype>
      <name name="sendfile_option"/>
    </datatype>
   </datatypes>

  <funcs>
    <func>
      <name name="advise" arity="4"/>
      <fsummary>Predeclare an access pattern for file data</fsummary>
      <type name="posix_file_advise"/>
      <desc>
        <p><c>advise/4</c> can be used to announce an intention to access file
          data in a specific pattern in the future, thus allowing the
          operating system to perform appropriate optimizations.</p>
        <p_zh><c>advise/4</c>可以用来预示一个通过某种模式访问文件数据的意向，使得操作系统进行适当的优化.</p_zh>
        <p>On some platforms, this function might have no effect.</p>
        <p_zh>在某些平台这个函数可能没有效果.</p_zh>
      </desc>
    </func>
    <func>
      <name name="change_group" arity="2"/>
      <fsummary>Change group of a file</fsummary>
      <desc>
        <p>Changes group of a file. See
          <seealso marker="#write_file_info/2">write_file_info/2</seealso>.</p>
        <p_zh>更改文件的所属组. 参阅
          <seealso marker="#write_file_info/2">write_file_info/2</seealso>.</p_zh>
      </desc>
    </func>
    <func>
      <name name="change_mode" arity="2"/>
      <fsummary>Change permissions of a file</fsummary>
      <desc>
        <p>Changes permissions of a file. See
          <seealso marker="#write_file_info/2">write_file_info/2</seealso>.</p>
        <p_zh>更改文件权限. 参阅
          <seealso marker="#write_file_info/2">write_file_info/2</seealso>.</p_zh>
      </desc>
    </func>
    <func>
      <name name="change_owner" arity="2"/>
      <fsummary>Change owner of a file</fsummary>
      <desc>
        <p>Changes owner of a file. See
          <seealso marker="#write_file_info/2">write_file_info/2</seealso>.</p>
        <p_zh>更改文件的所有者. 参阅
          <seealso marker="#write_file_info/2">write_file_info/2</seealso>.</p_zh>
      </desc>
    </func>
    <func>
      <name name="change_owner" arity="3"/>
      <fsummary>Change owner and group of a file</fsummary>
      <desc>
        <p>Changes owner and group of a file. See
          <seealso marker="#write_file_info/2">write_file_info/2</seealso>.</p>
        <p_zh>更改文件的所有者和所有组. 参阅
          <seealso marker="#write_file_info/2">write_file_info/2</seealso>.</p_zh>
      </desc>
    </func>
    <func>
      <name name="change_time" arity="2"/>
      <fsummary>Change the modification time of a file</fsummary>
      <desc>
        <p>Changes the modification and access times of a file. See
          <seealso marker="#write_file_info/2">write_file_info/2</seealso>.</p>
        <p_zh>更改文件的修改和访问时间. 参阅
          <seealso marker="#write_file_info/2">write_file_info/2</seealso>.</p_zh>
      </desc>
    </func>
    <func>
      <name name="change_time" arity="3"/>
      <fsummary>Change the modification and last access time of a file</fsummary>
      <desc>
        <p>Changes the modification and last access times of a file. See
          <seealso marker="#write_file_info/2">write_file_info/2</seealso>.</p>
        <p_zh>更改文件的修改和访问时间. 参阅
          <seealso marker="#write_file_info/2">write_file_info/2</seealso>.</p_zh>
      </desc>
    </func>
    <func>
      <name name="close" arity="1"/>
      <fsummary>Close a file</fsummary>
      <desc>
        <p>Closes the file referenced by <c><anno>IoDevice</anno></c>. It mostly
          returns <c>ok</c>, expect for some severe errors such as out
          of memory.</p>
        <p_zh>关闭<c><anno>IoDevice</anno></c>引用的文件. 这通常会返回<c>ok</c>, 除非发生像超出内存这样的服务器错误.</p_zh>
        <p>Note that if the option <c>delayed_write</c> was
          used when opening the file, <c>close/1</c> might return an
          old write error and not even try to close the file. See
          <seealso marker="#open/2">open/2</seealso>.</p>
        <p_zh>注意，如果在打开文件的时候使用了<c>delayed_write</c> 选项, <c>close/1</c> 可能返回一个过时写错误，甚至不会尝试关闭这个文件. 参阅 <seealso marker="#open/2">open/2</seealso>.</p_zh>
      </desc>
    </func>
    <func>
      <name name="consult" arity="1"/>
      <fsummary>Read Erlang terms from a file</fsummary>
      <desc>
        <p>Reads Erlang terms, separated by '.', from
           <c><anno>Filename</anno></c>. Returns one of the following:</p>
        <p_zh>从<c><anno>Filename</anno></c>中读取用'.'分隔的Erlang项. 返回下列其中一种:</p_zh>
        <taglist>
          <tag><c>{ok, <anno>Terms</anno>}</c></tag>
          <item>
            <p>The file was successfully read.</p>
            <p_zh>成功读取文件.</p_zh>
          </item>
          <tag><c>{error, atom()}</c></tag>
          <item>
            <p>An error occurred when opening the file or reading it.
              See <seealso marker="#open/2">open/2</seealso> for a list
              of typical error codes.</p>
            <p_zh>当打开或读文件的时候发生一个错误. 参阅 <seealso marker="#open/2">open/2</seealso> 中的典型错误代码.</p_zh>
          </item>
          <tag><c>{error, {<anno>Line</anno>, <anno>Mod</anno>,
                           <anno>Term</anno>}}</c></tag>
          <item>
            <p>An error occurred when interpreting the Erlang terms in
              the file. Use <c>format_error/1</c> to convert
              the three-element tuple to an English description of
              the error.</p>
            <p_zh>当翻译文件中的Erlang项时发生一个错误. 使用<c>format_error/1</c>来将三元素的元组翻译成错误的英文描述.</p_zh>
          </item>
        </taglist>
        <p>Example:</p>
        <p_zh>示例:</p_zh>
<code type="none">f.txt:  {person, "kalle", 25}.
        {person, "pelle", 30}.</code>
<pre>1> <input>file:consult("f.txt").</input>
{ok,[{person,"kalle",25},{person,"pelle",30}]}</pre>
      </desc>
    </func>
    <func>
      <name name="copy" arity="2"/>
      <name name="copy" arity="3"/>
      <fsummary>Copy file contents</fsummary>
      <desc>
        <p>Copies <c><anno>ByteCount</anno></c> bytes from
          <c><anno>Source</anno></c> to <c><anno>Destination</anno></c>.
          <c><anno>Source</anno></c> and <c><anno>Destination</anno></c> refer
          to either filenames or IO devices from e.g. <c>open/2</c>.
          <c><anno>ByteCount</anno></c> defaults to <c>infinity</c>, denoting an
          infinite number of bytes.</p>
        <p_zh>从<c><anno>Source</anno></c> 向 <c><anno>Destination</anno></c>拷贝<c><anno>ByteCount</anno></c>字节. <c><anno>Source</anno></c> 和 <c><anno>Destination</anno></c> 指向文件名或IO设备(例如<c>open/2</c>返回的IO). <c><anno>ByteCount</anno></c> 默认值 <c>infinity</c>, 代表无限字节.</p_zh>
        <p>The argument <c><anno>Modes</anno></c> is a list of possible modes,
          see <seealso marker="#open/2">open/2</seealso>, and defaults to
          [].</p>
        <p_zh>参数<c><anno>Modes</anno></c> 是一个模式列表, 参阅 <seealso marker="#open/2">open/2</seealso>, 默认值为[].</p_zh>
        <p>If both <c><anno>Source</anno></c> and
          <c><anno>Destination</anno></c> refer to
          filenames, the files are opened with <c>[read, binary]</c>
          and <c>[write, binary]</c> prepended to their mode lists,
          respectively, to optimize the copy.</p>
        <p_zh>如果<c><anno>Source</anno></c> 和 <c><anno>Destination</anno></c> 都是文件名, 那么这些文件将会分别以<c>[read, binary]</c> 和<c>[write, binary]</c> 作为模式列表的前缀来优化拷贝.</p_zh>
        <p>If <c><anno>Source</anno></c> refers to a filename, it is opened with
          <c>read</c> mode prepended to the mode list before the copy,
          and closed when done.</p>
        <p_zh>如果 <c><anno>Source</anno></c> 是一个文件名, 那么它会在拷贝之前以<c>read</c>作为模式列表的前缀打开, 并且在结束的时候关闭.</p_zh>
        <p>If <c><anno>Destination</anno></c> refers to a filename, it is opened
          with <c>write</c> mode prepended to the mode list before
          the copy, and closed when done.</p>
        <p_zh>如果 <c><anno>Destination</anno></c> 是一个文件名, 那么它会在拷贝之前以<c>write</c>作为模式列表的前缀打开, 并且在结束的时候关闭.</p_zh>
        <p>Returns <c>{ok, <anno>BytesCopied</anno>}</c> where
          <c><anno>BytesCopied</anno></c> is
          the number of bytes that actually was copied, which may be
          less than <c><anno>ByteCount</anno></c> if end of file was
          encountered on the source. If the operation fails,
          <c>{error, <anno>Reason</anno>}</c> is returned.</p>
        <p_zh>返回 <c>{ok, <anno>BytesCopied</anno>}</c> 其中<c><anno>BytesCopied</anno></c> 是实际拷贝的字节数，如果遇到了文件结束符可能会小于<c><anno>ByteCount</anno></c>. 如果操作失败返回 <c>{error, <anno>Reason</anno>}</c>.</p_zh>
        <p>Typical error reasons: As for <c>open/2</c> if a file had to
          be opened, and as for <c>read/2</c> and <c>write/2</c>.</p>
        <p_zh>典型的错误原因: 如果需要打开文件时参阅<c>open/2</c> , 以及<c>read/2</c> 和<c>write/2</c>.</p_zh>
      </desc>
    </func>
    <func>
      <name name="del_dir" arity="1"/>
      <fsummary>Delete a directory</fsummary>
      <desc>
        <p>Tries to delete the directory <c><anno>Dir</anno></c>.
          The directory must
          be empty before it can be deleted. Returns <c>ok</c> if
          successful.</p>
        <p_zh>尝试删除文件夹<c><anno>Dir</anno></c>.删除之前文件夹必须为空. 如果删除成功返回<c>ok</c>.</p_zh>
        <p>Typical error reasons are:</p>
        <p_zh>典型的错误原因:</p_zh>
        <taglist>
          <tag><c>eacces</c></tag>
          <item>
            <p>Missing search or write permissions for the parent
              directories of <c><anno>Dir</anno></c>.</p>
            <p_zh>缺少对<c><anno>Dir</anno></c>父文件夹的搜索和写权限.</p_zh>
          </item>
          <tag><c>eexist</c></tag>
          <item>
            <p>The directory is not empty.</p>
            <p_zh>文件夹不为空.</p_zh>
          </item>
          <tag><c>enoent</c></tag>
          <item>
            <p>The directory does not exist.</p>
            <p_zh>文件夹不存在.</p_zh>
          </item>
          <tag><c>enotdir</c></tag>
          <item>
            <p>A component of <c><anno>Dir</anno></c> is not a directory.
              On some platforms, <c>enoent</c> is returned instead.</p>
            <p_zh><c><anno>Dir</anno></c>路径中存在不是文件夹的部分. 在某些平台, 返回的是<c>enoent</c>.</p_zh>
          </item>
          <tag><c>einval</c></tag>
          <item>
            <p>Attempt to delete the current directory. On some
              platforms, <c>eacces</c> is returned instead.</p>
            <p_zh>试图删除当前文件夹. 在某些平台上, 返回的是<c>eacces</c>.</p_zh>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="delete" arity="1"/>
      <fsummary>Delete a file</fsummary>
      <desc>
        <p>Tries to delete the file <c><anno>Filename</anno></c>.
          Returns <c>ok</c> if successful.</p>
        <p_zh>尝试删除文件<c><anno>Filename</anno></c>.如果成功, 返回<c>ok</c>.</p_zh>
        <p>Typical error reasons are:</p>
        <p_zh>典型的错误原因:</p_zh>
        <taglist>
          <tag><c>enoent</c></tag>
          <item>
            <p>The file does not exist.</p>
            <p_zh>文件不存在.</p_zh>
          </item>
          <tag><c>eacces</c></tag>
          <item>
            <p>Missing permission for the file or one of its parents.</p>
            <p_zh>缺失该文件或者它其中一个父文件夹的权限.</p_zh>
          </item>
          <tag><c>eperm</c></tag>
          <item>
            <p>The file is a directory and the user is not super-user.</p>
            <p_zh>该文件是一个文件夹并且用户不是超级用户.</p_zh>
          </item>
          <tag><c>enotdir</c></tag>
          <item>
            <p>A component of the file name is not a directory. On some
              platforms, <c>enoent</c> is returned instead.</p>
            <p_zh>文件路径中有部分不是文件夹. 在某些平台上, 返回的是<c>enoent</c>.</p_zh>
          </item>
          <tag><c>einval</c></tag>
          <item>
            <p><c><anno>Filename</anno></c> had an improper type, such as tuple.</p>
            <p_zh><c><anno>Filename</anno></c>类型不正确, 例如元组.</p_zh>
          </item>
        </taglist>
        <warning>
          <p>In a future release, a bad type for the
            <c><anno>Filename</anno></c> argument will probably generate
            an exception.</p>
          <p_zh>在以后的版本中, <c><anno>Filename</anno></c>的类型错误问题可能会产生一个异常.</p_zh>
        </warning>
      </desc>
    </func>
    <func>
      <name name="eval" arity="1"/>
      <fsummary>Evaluate Erlang expressions in a file</fsummary>
      <desc>
        <p>Reads and evaluates Erlang expressions, separated by '.' (or
          ',', a sequence of expressions is also an expression), from
          <c><anno>Filename</anno></c>. The actual result of the evaluation
          is not returned; any expression sequence in the file must be there
          for its side effect. Returns one of the following:</p>
        <p_zh>从<c><anno>Filename</anno></c>读取并且计算Erlang表达式, separated by '.' (or
          ',', a sequence of expressions is also an expression), from
          . 实际的计算结果并不返回; 并且任何any expression sequence in the file must be there
          for its side effect. 返回下列之一:</p_zh>
        <taglist>
          <tag><c>ok</c></tag>
          <item>
            <p>The file was read and evaluated.</p>
            <p_zh>文件被读取并计算.</p_zh>
          </item>
          <tag><c>{error, atom()}</c></tag>
          <item>
            <p>An error occurred when opening the file or reading it.
              See <c>open/2</c> for a list of typical error codes.</p>
            <p_zh>在打开或读取文件的时候遇到一个错误. 参阅 <c>open/2</c> 中的典型错误代码.</p_zh>
          </item>
          <tag><c>{error, {<anno>Line</anno>, <anno>Mod</anno>,
                           <anno>Term</anno>}}</c></tag>
          <item>
            <p>An error occurred when interpreting the Erlang
              expressions in the file. Use <c>format_error/1</c> to
              convert the three-element tuple to an English description
              of the error.</p>
            <p_zh>在解释文件中的Erlang表达式时遇到一个错误. 使用 <c>format_error/1</c> 函数将三元素元组转换成错误的英文描述信息.</p_zh>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="eval" arity="2"/>
      <fsummary>Evaluate Erlang expressions in a file</fsummary>
      <desc>
        <p>The same as <c>eval/1</c> but the variable bindings
          <c><anno>Bindings</anno></c> are used in the evaluation. See
          <seealso marker="stdlib:erl_eval">erl_eval(3)</seealso> about
          variable bindings.</p>
        <p_zh>除了在计算过程中使用变量绑定<c><anno>Bindings</anno></c> 以外与<c>eval/1</c>相同. 参阅 <seealso marker="stdlib:erl_eval">erl_eval(3)</seealso> 中关于变量绑定的内容.</p_zh>
      </desc>
    </func>
    <func>
      <name>file_info(Filename) -> {ok, FileInfo} | {error, Reason}</name>
      <fsummary>Get information about a file (deprecated)</fsummary>
      <desc>
        <p>This function is obsolete. Use <c>read_file_info/1,2</c>
          instead.</p>
        <p_zh>该函数已过时. 请使用<c>read_file_info/1,2</c>.</p_zh>
      </desc>
    </func>
    <func>
      <name name="format_error" arity="1"/>
      <fsummary>Return a descriptive string for an error reason</fsummary>
      <desc>
        <p>Given the error reason returned by any function in this
          module, returns a descriptive string of the error in English.</p>
        <p_zh>给定一个由本模块任何一个函数返回的错误原因, 返回该错误的英文描述字符串.</p_zh>
      </desc>
    </func>
    <func>
      <name name="get_cwd" arity="0"/>
      <fsummary>Get the current working directory</fsummary>
      <desc>
        <p>Returns <c>{ok, <anno>Dir</anno>}</c>, where <c><anno>Dir</anno></c>
          is the current
          working directory of the file server.</p>
        <p_zh>返回 <c>{ok, <anno>Dir</anno>}</c>, 其中 <c><anno>Dir</anno></c>是文件服务器的当前工作目录.</p_zh>
        <note>
          <p>In rare circumstances, this function can fail on Unix.
            It may happen if read permission does not exist for
            the parent directories of the current directory.</p>
          <p_zh>特殊环境下, 该函数在Unix系统上会失败. 这可能发生在没有当前文件夹路径上父文件夹的读权限时.</p_zh>
        </note>
        <p>Typical error reasons are:</p>
        <p_zh>典型的错误原因:</p_zh>
        <taglist>
          <tag><c>eacces</c></tag>
          <item>
            <p>Missing read permission for one of the parents of
              the current directory.</p>
            <p_zh>缺失当前文件夹路径上某个父文件夹的读权限.</p_zh>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="get_cwd" arity="1"/>
      <fsummary>Get the current working directory for the drive specified</fsummary>
      <desc>
        <p><c><anno>Drive</anno></c> should be of the form
          "<c>Letter</c><c>:</c>",
          for example "c:". Returns <c>{ok, <anno>Dir</anno>}</c> or
          <c>{error, <anno>Reason</anno>}</c>, where <c><anno>Dir</anno></c>
          is the current
          working directory of the drive specified.</p>
        <p_zh><c><anno>Drive</anno></c> 应该是"<c>Letter</c><c>:</c>"的形式,
          例如"c:". 返回 <c>{ok, <anno>Dir</anno>}</c> 或 <c>{error, <anno>Reason</anno>}</c>, 其中 <c><anno>Dir</anno></c> 是指定分区上的当前工作目录.</p_zh>
        <p>This function returns <c>{error, enotsup}</c> on platforms
          which have no concept of current drive (Unix, for example).</p>
        <p_zh>该函数在没有当前分区概念的平台(例如Unix)上返回<c>{error, enotsup}</c>.</p_zh>
        <p>Typical error reasons are:</p>
        <p_zh>典型的错误原因:</p_zh>
        <taglist>
          <tag><c>enotsup</c></tag>
          <item>
            <p>The operating system has no concept of drives.</p>
            <p_zh>当前操作系统没有分区的概念.</p_zh>
          </item>
          <tag><c>eacces</c></tag>
          <item>
            <p>The drive does not exist.</p>
            <p_zh>分区不存在.</p_zh>
          </item>
          <tag><c>einval</c></tag>
          <item>
            <p>The format of <c><anno>Drive</anno></c> is invalid.</p>
            <p_zh><c><anno>Drive</anno></c>格式不合法.</p_zh>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="list_dir" arity="1"/>
      <fsummary>List files in a directory</fsummary>
      <desc>
        <p>Lists all the files in a directory. Returns
          <c>{ok, <anno>Filenames</anno>}</c> if successful.
          Otherwise, it returns <c>{error, <anno>Reason</anno>}</c>.
          <c><anno>Filenames</anno></c> is a list of
          the names of all the files in the directory. The names are
          not sorted.</p>
        <p_zh>列出文件夹下的所有文件. 如果成功, 返回<c>{ok, <anno>Filenames</anno>}</c>.
          否则, 返回<c>{error, <anno>Reason</anno>}</c>. <c><anno>Filenames</anno></c> 是一个包含文件夹中所有文件名的列表. 这些名字没有保存下来.</p_zh>
        <p>Typical error reasons are:</p>
        <p_zh>典型的错误原因:</p_zh>
        <taglist>
          <tag><c>eacces</c></tag>
          <item>
            <p>Missing search or write permissions for <c><anno>Dir</anno></c>
              or one of its parent directories.</p>
            <p_zh>缺失<c><anno>Dir</anno></c>某个父文件夹的搜索或写权限.</p_zh>
          </item>
          <tag><c>enoent</c></tag>
          <item>
            <p>The directory does not exist.</p>
            <p_zh>文件夹不存在.</p_zh>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="make_dir" arity="1"/>
      <fsummary>Make a directory</fsummary>
      <desc>
        <p>Tries to create the directory <c><anno>Dir</anno></c>. Missing parent
          directories are <em>not</em> created. Returns <c>ok</c> if
          successful.</p>
        <p_zh>尝试创建文件夹<c><anno>Dir</anno></c>. 缺失父文件夹时<em>不</em>创建文件夹. 如果成功, 返回<c>ok</c>.</p_zh>
        <p>Typical error reasons are:</p>
        <p_zh>典型的错误原因:</p_zh>
        <taglist>
          <tag><c>eacces</c></tag>
          <item>
            <p>Missing search or write permissions for the parent
              directories of <c><anno>Dir</anno></c>.</p>
            <p_zh>缺失<c><anno>Dir</anno></c>某些父文件夹的搜索或写权限.</p_zh>
          </item>
          <tag><c>eexist</c></tag>
          <item>
            <p>There is already a file or directory named <c><anno>Dir</anno></c>.</p>
            <p_zh>已存在一个以<c><anno>Dir</anno></c>命名的文件或文件夹.</p_zh>
          </item>
          <tag><c>enoent</c></tag>
          <item>
            <p>A component of <c><anno>Dir</anno></c> does not exist.</p>
            <p_zh><c><anno>Dir</anno></c>路径名中某部分不存在.</p_zh>
          </item>
          <tag><c>enospc</c></tag>
          <item>
            <p>There is a no space left on the device.</p>
            <p_zh>空间不足.</p_zh>
          </item>
          <tag><c>enotdir</c></tag>
          <item>
            <p>A component of <c><anno>Dir</anno></c> is not a directory.
              On some platforms, <c>enoent</c> is returned instead.</p>
            <p_zh><c><anno>Dir</anno></c>路径名中某部分不是文件夹. 在某些平台上返回的是<c>enoent</c>.</p_zh>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="make_link" arity="2"/>
      <fsummary>Make a hard link to a file</fsummary>
      <desc>
        <p>Makes a hard link from <c><anno>Existing</anno></c> to
          <c><anno>New</anno></c>, on
          platforms that support links (Unix and Windows). This function returns
          <c>ok</c> if the link was successfully created, or
          <c>{error, <anno>Reason</anno>}</c>. On platforms that do not support
          links, <c>{error,enotsup}</c> is returned.</p>
        <p_zh>在支持链接的平台上（例如unix, windows)创建一个从<c><anno>Existing</anno></c>到<c><anno>New</anno></c>的硬链接. 如果链接创建成功返回 <c>ok</c>, 否则返回 <c>{error, <anno>Reason</anno>}</c>. 在不支持链接的平台上, 返回<c>{error,enotsup}</c> .</p_zh>
        <p>Typical error reasons:</p>
        <p_zh>典型的错误原因:</p_zh>
        <taglist>
          <tag><c>eacces</c></tag>
          <item>
            <p>Missing read or write permissions for the parent
              directories of <c><anno>Existing</anno></c> or
              <c><anno>New</anno></c>.</p>
            <p_zh>缺失<c><anno>Existing</anno></c> 或 <c><anno>New</anno></c>父文件夹的读或写权限.</p_zh>
          </item>
          <tag><c>eexist</c></tag>
          <item>
            <p><c><anno>New</anno></c> already exists.</p>
            <p_zh><c><anno>New</anno></c>已存在.</p_zh>
          </item>
          <tag><c>enotsup</c></tag>
          <item>
            <p>Hard links are not supported on this platform.</p>
            <p_zh>当前平台不支持硬链接.</p_zh>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="make_symlink" arity="2"/>
      <fsummary>Make a symbolic link to a file or directory</fsummary>
      <desc>
        <p>This function creates a symbolic link <c><anno>New</anno></c> to
          the file or directory <c><anno>Existing</anno></c>, on platforms that
          support symbolic links (most Unix systems and Windows beginning with
	  Vista).
	  <c><anno>Existing</anno></c> need not exist.
          This function returns <c>ok</c> if the link was
          successfully created, or <c>{error, <anno>Reason</anno>}</c>.
          On platforms
          that do not support symbolic links, <c>{error, enotsup}</c>
          is returned.</p>
        <p_zh>在支持符号链接的平台上（例如unix, Vista之后的windows)创建一个从<c><anno>Existing</anno></c>到<c><anno>New</anno></c>的符号链接. <c><anno>Existing</anno></c>不必一定存在. 如果创建成功返回 <c>ok</c>, 否则返回 <c>{error, <anno>Reason</anno>}</c>. 在不支持符号链接的平台上, 返回<c>{error,enotsup}</c> .</p_zh>
        <p>Typical error reasons:</p>
        <p_zh>典型的错误原因:</p_zh>
        <taglist>
          <tag><c>eacces</c></tag>
          <item>
            <p>Missing read or write permissions for the parent directories
            of <c><anno>Existing</anno></c> or <c><anno>New</anno></c>.</p>
            <p_zh>缺失<c><anno>Existing</anno></c> 或 <c><anno>New</anno></c>父文件夹的读或写权限.</p_zh>
          </item>
          <tag><c>eexist</c></tag>
          <item>
            <p><c><anno>New</anno></c> already exists.</p>
            <p_zh><c><anno>New</anno></c> 已存在.</p_zh>
          </item>
          <tag><c>enotsup</c></tag>
          <item>
            <p>Symbolic links are not supported on this platform.</p>
            <p_zh>当前平台不支持符号链接.</p_zh>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name>native_name_encoding() -> latin1 | utf8</name>
      <fsummary>Return the VM's configured filename encoding.</fsummary>
      <desc>
        <p>This function returns the configured default file name encoding to use for raw file names. Generally an application supplying file names raw (as binaries), should obey the character encoding returned by this function.</p>
	<p>By default, the VM uses ISO-latin-1 file name encoding on filesystems and/or OSes that use completely transparent file naming. This includes all Unix versions except MacOSX, where the vfs layer enforces UTF-8 file naming. By giving the experimental option <c>+fnu</c> when starting Erlang, UTF-8 translation of file names can be turned on even for those systems. If Unicode file name translation is in effect, the system behaves as usual as long as file names conform to the encoding, but will return file names that are not properly encoded in UTF-8 as raw file names (i.e. binaries).</p> 
	<p>On Windows, this function also returns <c>utf8</c> by default. The OS uses a pure Unicode naming scheme and file names are always possible to interpret as valid Unicode. The fact that the underlying Windows OS actually encodes file names using little endian UTF-16 can be ignored by the Erlang programmer. Windows and MacOSX are the only operating systems where the VM operates in Unicode file name mode by default.</p>
      </desc>
    </func>
    <func>
      <name name="open" arity="2"/>
      <fsummary>Open a file</fsummary>
      <desc>
        <p>Opens the file <c><anno>Filename</anno></c> in the mode determined
          by <c><anno>Modes</anno></c>, which may contain one or more of the
          following items:</p>
        <p_zh>以由<c><anno>Modes</anno></c>确定的模式打开文件<c><anno>Filename</anno></c>, 这些模式可以包含下述一个或多个项:</p_zh>
        <taglist>
          <tag><c>read</c></tag>
          <item>
            <p>The file, which must exist, is opened for reading.</p>
            <p_zh>打开已存在的文件来进行读操作.</p_zh>
          </item>
          <tag><c>write</c></tag>
          <item>
            <p>The file is opened for writing. It is created if it does
              not exist. If the file exists, and if <c>write</c> is not
              combined with <c>read</c>, the file will be truncated.</p>
            <p_zh>打开文件来进行写操作. 如果文件不存在，创建一个新文件. 如果文件存在, 并且<c>write</c> 不和<c>read</c>一起使用时, 文件将被截断(清空）.</p_zh>
          </item>
          <tag><c>append</c></tag>
          <item>
            <p>The file will be opened for writing, and it will be
              created if it does not exist. Every write operation to a
              file opened with <c>append</c> will take place at
              the end of the file.</p>
            <p_zh>打开文件来进行写操作, 如果文件不存在则创建新文件. 当写以<c>append</c>模式打开的文件时, 写操作发生在文件的结尾.</p_zh>
          </item>
          <tag><c>exclusive</c></tag>
          <item>
            <p>The file, when opened for writing, is created if it
              does not exist. If the file exists, open will return
              <c>{error, eexist}</c>.</p>
            <p_zh>当打开来进行写操作的文件不存在时，创建一个新文件. 如果文件存在, open返回 <c>{error, eexist}</c>.</p_zh>
	    <warning><p>This option does not guarantee exclusiveness on
	    file systems that do not support O_EXCL properly,
	    such as NFS. Do not depend on this option unless you
	    know that the file system supports it (in general, local
        file systems should be safe).</p>
        <p_zh>在像NFS这样不能很好的支持O_EXCL的文件系统上，该选项不能确保排它性的实现. 除非你知道当前的文件系统支持这个选项(通常本地文件系统是安全支持的)，否则不要依赖它.</p_zh>
        </warning>
          </item>
          <tag><c>raw</c></tag>
          <item>
            <p>The <c>raw</c> option allows faster access to a file,
              because no Erlang process is needed to handle the file.
              However, a file opened in this way has the following
              limitations:</p>
            <p_zh><c>raw</c>选项可以使文件的访问更快, 因为这样在处理文件的时候不再需要Erlang的进程. 然而，用这种方式打开的文件有下列限制:</p_zh>
            <list type="bulleted">
              <item>The functions in the <c>io</c> module cannot be used,
               because they can only talk to an Erlang process.
               Instead, use the <c>read/2</c>, <c>read_line/1</c> and 
	       <c>write/2</c>
               functions.</item>
              <item_zh>不能使用<c>io</c>模块中的函数, 因为这些函数只能和Erlang进程通信. 作为代替, 可以使用<c>read/2</c>, <c>read_line/1</c> 以及 <c>write/2</c> 函数.</item_zh>
	      <item>Especially if <c>read_line/1</c> is to be used on a <c>raw</c> file, it is recommended to combine this option with the <c>{read_ahead, Size}</c> option as line oriented I/O is inefficient without buffering.</item>
	      <item_zh>特别是 if <c>read_line/1</c> is to be used on a <c>raw</c> file, it is recommended to combine this option with the <c>{read_ahead, Size}</c> option as line oriented I/O is inefficient without buffering.</item_zh>
              <item>Only the Erlang process which opened the file can use
               it.</item>
              <item_zh>只能由打开文件的进程使用这个文件.</item_zh>
              <item>A remote Erlang file server cannot be used;
               the computer on which the Erlang node is running must
               have access to the file system (directly or through
               NFS).</item>
              <item_zh>不能使用远程的Erlang文件系统; 运行Erlang节点的计算机必须直接或者通过NFS访问该文件系统.</item_zh>
            </list>
          </item>
          <tag><c>binary</c></tag>
          <item>
            <p>When this option has been given, read operations on the file
	       will return binaries rather than lists.</p>
            <p_zh>当给定这个选项时, 对文件的读操作将会返回二进制串而不是列表.</p_zh>
          </item>
          <tag><c>{delayed_write, Size, Delay}</c></tag>
          <item>
            <p>If this option is used, the data in subsequent
              <c>write/2</c> calls is buffered until there are at least
              <c>Size</c> bytes buffered, or until the oldest buffered
              data is <c>Delay</c> milliseconds old. Then all buffered
              data is written in one operating system call.
              The buffered data is also flushed before some other file
              operation than <c>write/2</c> is executed.</p>
            <p_zh>如果使用这个选项, 那么后续<c>write/2</c>函数调用中的数据将会在达到或者超过<c>Size</c>字节之前一直被缓存，或者最早的缓存数据已经超过了<c>Delay</c>毫秒. 之后，所有缓存的数据将会通过一次系统函数调用写入. 缓冲数据也在除了<c>write/2</c>以外的文件操作执行之前被冲刷.</p_zh>
            <p>The purpose of this option is to increase performance
              by reducing the number of operating system calls, so the
              <c>write/2</c> calls should be for sizes significantly
              less than <c>Size</c>, and not interspersed by to many
              other file operations, for this to happen.</p>
            <p_zh>这个选项的目的是通过减少系统调用的次数来提高性能
             为了能达到这个效果， <c>write/2</c> 函数调用应该适用于远小于<c>Size</c>的数据, 并且不能穿插在其他文件操作当中.</p_zh>
            <p>When this option is used, the result of <c>write/2</c>
              calls may prematurely be reported as successful, and if
              a write error should actually occur the error is
              reported as the result of the next file operation, which
              is not executed.</p>
            <p_zh>当使用这个选项的时候, <c>write/2</c>马上返回成功的返回结果，如果遇到一个写时错误，那么将延迟到下次文件操作时报错（报错时的文件操作没有执行）. </p_zh>
            <p>For example, when <c>delayed_write</c> is used, after a
              number of <c>write/2</c> calls, <c>close/1</c> might
              return <c>{error, enospc}</c> because there was not enough
              space on the disc for previously written data, and
              <c>close/1</c> should probably be called again since the
              file is still open.</p>
            <p_zh>例如, 当使用<c>delayed_write</c>时, 在一系列的<c>write/2</c>的调用之后, <c>close/1</c> 可能返回<c>{error, enospc}</c> 这是因为没有足够的磁盘空间分配给之前写入的数据, 而且应该再次调用<c>close/1</c>函数来关闭仍处于打开状态的文件.</p_zh>
          </item>
          <tag><c>delayed_write</c></tag>
          <item>
            <p>The same as <c>{delayed_write, Size, Delay}</c> with
              reasonable default values for <c>Size</c> and
              <c>Delay</c>. (Roughly some 64 KBytes, 2 seconds)</p>
            <p_zh>等同于拥有<c>Size</c> 和 <c>Delay</c>默认值(大约是64字节, 2秒钟)的<c>{delayed_write, Size, Delay}</c>. </p_zh>
          </item>
          <tag><c>{read_ahead, Size}</c></tag>
          <item>
            <p>This option activates read data buffering. If
              <c>read/2</c> calls are for significantly less than
              <c>Size</c> bytes, read operations towards the operating
              system are still performed for blocks of <c>Size</c>
              bytes. The extra data is buffered and returned in
              subsequent <c>read/2</c> calls, giving a performance gain
              since the number of operating system calls is reduced.</p>
            <p_zh>该选项激活了读操作数据缓冲区. <c>read/2</c>函数调用是针对于远小于<c>Size</c>字节的数据, 面向操作系统的读操作仍然操作于<c>Size</c>字节大小的数据块. 额外的数据被缓冲下来待下次<c>read/2</c>调用时返回, 这样就通过减少了系统调用次数而获得性能的提高.</p_zh>
	    <p>The <c>read_ahead</c> buffer is also highly utilized
	      by the <c>read_line/1</c> function in <c>raw</c> mode,
	      why this option is recommended (for performance reasons)
	      when accessing raw files using that function.</p>
	    <p_zh>The <c>read_ahead</c> buffer is also highly utilized
	      by the <c>read_line/1</c> function in <c>raw</c> mode,
	      why this option is recommended (for performance reasons)
	      when accessing raw files using that function.</p_zh>
            <p>If <c>read/2</c> calls are for sizes not significantly
              less than, or even greater than <c>Size</c> bytes, no
              performance gain can be expected.</p>
            <p_zh>如果<c>read/2</c>函数调用的数据并不远小于, 或者大于<c>Size</c>字节, 那么将不能获得预期的高性能.</p_zh>
          </item>
          <tag><c>read_ahead</c></tag>
          <item>
            <p>The same as <c>{read_ahead, Size}</c> with a reasonable
              default value for <c>Size</c>. (Roughly some 64 KBytes)</p>
            <p_zh>除了<c>Size</c>拥有一个合理的默认值(大概是64KB), 与<c>{read_ahead, Size}</c>相同. </p_zh>
          </item>
          <tag><c>compressed</c></tag>
          <item>
            <p>Makes it possible to read or write gzip compressed
              files. The <c>compressed</c> option must be combined
	      with either <c>read</c> or <c>write</c>, but not both.
	      Note that the file size obtained with
              <c>read_file_info/1</c> will most probably not match the
              number of bytes that can be read from a compressed file.</p>
            <p_zh>使读或写gzip压缩文件成为可能. <c>compressed</c> 选项必须和<c>read</c> 或 <c>write</c>其中之一一起使用.  注意, 通过<c>read_file_info/1</c>函数调用获得的文件大小可能与可读的压缩文件字节数目不匹配.</p_zh>
          </item>
          <tag><c>{encoding, Encoding}</c></tag>
          <item>
            <p>Makes the file perform automatic translation of characters to and from a specific (Unicode) encoding. Note that the data supplied to file:write or returned by file:read still is byte oriented, this option only denotes how data is actually stored in the disk file.</p>
	    <p>Depending on the encoding, different methods of reading and writing data is preferred. The default encoding of <c>latin1</c> implies using this (the file) module for reading and writing data, as the interfaces provided here work with byte-oriented data, while using other (Unicode) encodings makes the  <seealso marker="stdlib:io">io(3)</seealso> module's <c>get_chars</c>, <c>get_line</c> and <c>put_chars</c> functions more suitable, as they can work with the full Unicode range.</p>
	    <p>If data is sent to an <c>io_device()</c> in a format that cannot be converted to the specified encoding, or if data is read by a function that returns data in a format that cannot cope with the character range of the data, an error occurs and the file will be closed.</p> 
	    <p>The allowed values for <c>Encoding</c> are:</p>
	    <p_zh><c>Encoding</c>的可用值:</p_zh>
	    <taglist>
	    <tag><c>latin1</c></tag>
	    <item>
	    <p>The default encoding. Bytes supplied to i.e. file:write are written as is on the file, likewise bytes read from the file are returned to i.e. file:read as is. If the <seealso marker="stdlib:io">io(3)</seealso> module is used for writing, the file can only cope with Unicode characters up to codepoint 255 (the ISO-latin-1 range).</p>
	    </item>
	    <tag><c>unicode</c> or <c>utf8</c></tag>
	    <item>
	    <p>Characters are translated to and from the UTF-8 encoding before being written to or read from the file. A file opened in this way might be readable using the file:read function, as long as no data stored on the file lies beyond the ISO-latin-1 range (0..255), but failure will occur if the data contains Unicode codepoints beyond that range. The file is best read with the functions in the Unicode aware   <seealso marker="stdlib:io">io(3)</seealso> module.</p>
	    <p>Bytes written to the file by any means are translated to UTF-8 encoding before actually being stored on the disk file.</p>
	    </item>
	    <tag><c>utf16</c> or <c>{utf16,big}</c></tag>
	    <item>
	    <p>Works like <c>unicode</c>, but translation is done to and from big endian UTF-16 instead of UTF-8.</p>
	    </item>
	    <tag><c>{utf16,little}</c></tag>
	    <item>
	    <p>Works like <c>unicode</c>, but translation is done to and from little endian UTF-16 instead of UTF-8.</p>
	    </item>
	    <tag><c>utf32</c> or <c>{utf32,big}</c></tag>
	    <item>
	    <p>Works like <c>unicode</c>, but translation is done to and from big endian UTF-32 instead of UTF-8.</p>
	    </item>
	    <tag><c>{utf32,little}</c></tag>
	    <item>
	    <p>Works like <c>unicode</c>, but translation is done to and from little endian UTF-32 instead of UTF-8.</p>
	    </item>
	    </taglist>
	    <p>The Encoding can be changed for a file "on the fly" by using the <seealso marker="stdlib:io#setopts/2">io:setopts/2</seealso> function, why a file can be analyzed in latin1 encoding for i.e. a BOM, positioned beyond the BOM and then be set for the right encoding before further reading.See the <seealso marker="stdlib:unicode">unicode(3)</seealso> module for functions identifying BOM's.</p>
	    <p>This option is not allowed on <c>raw</c> files.</p>
          </item>
        </taglist>
        <p>Returns:</p>
        <p_zh>返回值:</p_zh>
        <taglist>
          <tag><c>{ok, <anno>IoDevice</anno>}</c></tag>
          <item>
            <p>The file has been opened in the requested mode.
              <c><anno>IoDevice</anno></c> is a reference to the file.</p>
            <p_zh>文件已经按照要求的模式打开. <c><anno>IoDevice</anno></c>是该文件的一个引用.</p_zh>
          </item>
          <tag><c>{error, <anno>Reason</anno>}</c></tag>
          <item>
            <p>The file could not be opened.</p>
            <p_zh>不能打开文件.</p_zh>
          </item>
        </taglist>
        <p><c><anno>IoDevice</anno></c> is really the pid of the process which
          handles the file. This process is linked to the process
          which originally opened the file. If any process to which
          the <c><anno>IoDevice</anno></c> is linked terminates, the file will
          be closed and the process itself will be terminated.
          An <c><anno>IoDevice</anno></c> returned from this call can be used
          as an argument to the IO functions (see
          <seealso marker="stdlib:io">io(3)</seealso>).</p>
        <p_zh><c><anno>IoDevice</anno></c> 是处理文件的进程号. 该进程与最初打开文件的进程相链接. 如果<c><anno>IoDevice</anno></c>链接的任意一个进程终止，那么文件将被关闭而该进程也会被终止.  由该函数调用返回的 <c><anno>IoDevice</anno></c> 可以作为IO函数的参数(参阅
          <seealso marker="stdlib:io">io(3)</seealso>).</p_zh>
        <note>
          <p>In previous versions of <c>file</c>, modes were given
            as one of the atoms <c>read</c>, <c>write</c>, or
            <c>read_write</c> instead of a list. This is still allowed
            for reasons of backwards compatibility, but should not be
            used for new code. Also note that <c>read_write</c> is not
            allowed in a mode list.</p>
          <p_zh>在<c>file</c>之前的版本中, 模式是通过给定<c>read</c>, <c>write</c>, 或者 <c>read_write</c>其中一个原子而不是一个列表指出的. 出于向后兼容的原因，仍然可以使用这种方式，但是对于新代码就不应该使用了. 同时也请注意<c>read_write</c>不能出现在模式列表中.</p_zh>
        </note>
        <p>Typical error reasons:</p>
        <p_zh>典型的错误原因:</p_zh>
        <taglist>
          <tag><c>enoent</c></tag>
          <item>
            <p>The file does not exist.</p>
            <p_zh>文件不存在.</p_zh>
          </item>
          <tag><c>eacces</c></tag>
          <item>
            <p>Missing permission for reading the file or searching one
              of the parent directories.</p>
            <p_zh>缺失该文件的读权限或者某个父文件夹的搜索权限.</p_zh>
          </item>
          <tag><c>eisdir</c></tag>
          <item>
            <p>The named file is not a regular file. It may be a
              directory, a fifo, or a device.</p>
            <p_zh>该命名的文件不是一个普通文件. 它可能是一个目录，一个FIFO管道文件，或者一个设备</p_zh>
          </item>
          <tag><c>enotdir</c></tag>
          <item>
            <p>A component of the file name is not a directory. On some
              platforms, <c>enoent</c> is returned instead.</p>
            <p_zh>文件路径的某个组成部分不是文件夹. 在某些平台上, 返回的是<c>enoent</c>.</p_zh>
          </item>
          <tag><c>enospc</c></tag>
          <item>
            <p>There is a no space left on the device (if <c>write</c>
              access was specified).</p>
            <p_zh>空间不足(如果指定了<c>write</c>访问).</p_zh>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="path_consult" arity="2"/>
      <fsummary>Read Erlang terms from a file</fsummary>
      <desc>
        <p>Searches the path <c><anno>Path</anno></c> (a list of directory
          names) until the file <c><anno>Filename</anno></c> is found.
          If <c><anno>Filename</anno></c>
          is an absolute filename, <c><anno>Path</anno></c> is ignored.
          Then reads Erlang terms, separated by '.', from the file.
          Returns one of the following:</p>
        <p_zh>搜索路径<c><anno>Path</anno></c> (一个文件夹路径列表) 直到发现<c><anno>Filename</anno></c>文件. 如果<c><anno>Filename</anno></c>是一个绝对路径, 那么将会忽略<c><anno>Path</anno></c>. 之后从文件中读取以'.'分隔的Erlang项. 返回下列之一:</p_zh>
        <taglist>
          <tag><c>{ok, <anno>Terms</anno>, <anno>FullName</anno>}</c></tag>
          <item>
            <p>The file was successfully read. <c><anno>FullName</anno></c> is
              the full name of the file.</p>
            <p_zh>成功读取文件. <c><anno>FullName</anno></c>是文件的完整路径名.</p_zh>
          </item>
          <tag><c>{error, enoent}</c></tag>
          <item>
            <p>The file could not be found in any of the directories in
              <c><anno>Path</anno></c>.</p>
            <p_zh>列表<c><anno>Path</anno></c>里所有的文件夹中都未找到目标文件.</p_zh>
          </item>
          <tag><c>{error, atom()}</c></tag>
          <item>
            <p>An error occurred when opening the file or reading it.
              See <seealso marker="#open/2">open/2</seealso> for a list
              of typical error codes.</p>
            <p_zh>在打开或者读取文件的时候发生一个错误. 参阅 <seealso marker="#open/2">open/2</seealso> 中的典型错误代码列表.</p_zh>
          </item>
          <tag><c>{error, {<anno>Line</anno>, <anno>Mod</anno>,
                           <anno>Term</anno>}}</c></tag>
          <item>
            <p>An error occurred when interpreting the Erlang terms in
              the file. Use <c>format_error/1</c> to convert
              the three-element tuple to an English description of
              the error.</p>
            <p_zh>当翻译文件中的Erlang项时发生一个错误. 使用<c>format_error/1</c>来将三元素的元组翻译成错误的英文描述.</p_zh>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="path_eval" arity="2"/>
      <fsummary>Evaluate Erlang expressions in a file</fsummary>
      <desc>
        <p>Searches the path <c><anno>Path</anno></c> (a list of directory
          names) until the file <c><anno>Filename</anno></c> is found.
          If <c><anno>Filename</anno></c> is an absolute file name,
          <c><anno>Path</anno></c> is ignored. Then reads
          and evaluates Erlang expressions, separated by '.' (or ',', a
          sequence of expressions is also an expression), from the file.
          The actual result of evaluation is not returned; any
          expression sequence in the file must be there for its side
          effect. Returns one of the following:</p>
        <p_zh>搜索路径<c><anno>Path</anno></c> (一个文件夹路径列表) 直到发现<c><anno>Filename</anno></c>文件. 如果<c><anno>Filename</anno></c>是一个绝对路径, 那么将会忽略<c><anno>Path</anno></c>. Then reads and evaluates Erlang expressions, separated by '.' (or ',', a sequence of expressions is also an expression), from the file.
          The actual result of evaluation is not returned; any
          expression sequence in the file must be there for its side
          effect. Returns one of the following:</p_zh>
        <taglist>
          <tag><c>{ok, <anno>FullName</anno>}</c></tag>
          <item>
            <p>The file was read and evaluated. <c><anno>FullName</anno></c> 是完整的文件路径.</p>
            <p_zh>读取并求值. <c><anno>FullName</anno></c> 是文件的完整路径名.</p_zh>
          </item>
          <tag><c>{error, enoent}</c></tag>
          <item>
            <p>The file could not be found in any of the directories in
              <c><anno>Path</anno></c>.</p>
            <p_zh>列表<c><anno>Path</anno></c>里所有的文件夹中都未找到目标文件.</p_zh>
          </item>
          <tag><c>{error, atom()}</c></tag>
          <item>
            <p>An error occurred when opening the file or reading it.
              See <seealso marker="#open/2">open/2</seealso> for a list
              of typical error codes.</p>
            <p_zh>在打开或者读取文件的时候发生一个错误. 参阅 <seealso marker="#open/2">open/2</seealso> 中的典型错误代码列表.</p_zh>
          </item>
          <tag><c>{error, {<anno>Line</anno>, <anno>Mod</anno>,
                           <anno>Term</anno>}}</c></tag>
          <item>
            <p>An error occurred when interpreting the Erlang
              expressions in the file. Use <c>format_error/1</c> to
              convert the three-element tuple to an English description
              of the error.</p>
            <p_zh>当翻译文件中的Erlang项时发生一个错误. 使用<c>format_error/1</c>来将三元素的元组翻译成错误的英文描述.</p_zh>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="path_open" arity="3"/>
      <fsummary>Open a file</fsummary>
      <desc>
        <p>Searches the path <c><anno>Path</anno></c> (a list of directory
          names) until the file <c><anno>Filename</anno></c> is found.
          If <c><anno>Filename</anno></c>
          is an absolute file name, <c><anno>Path</anno></c> is ignored.
          Then opens the file in the mode determined by <c><anno>Modes</anno></c>.
          Returns one of the following:</p>
        <p_zh>搜索路径<c><anno>Path</anno></c> (一个文件夹路径列表) 直到发现<c><anno>Filename</anno></c>文件. 如果<c><anno>Filename</anno></c>是一个绝对路径, 那么将会忽略<c><anno>Path</anno></c>. 之后以<c><anno>Modes</anno></c>确定的模式打开文件.  返回下列之一:</p_zh>
        <taglist>
          <tag><c>{ok, <anno>IoDevice</anno>, <anno>FullName</anno>}</c></tag>
          <item>
            <p>The file has been opened in the requested mode.
              <c><anno>IoDevice</anno></c> is a reference to the file and
              <c><anno>FullName</anno></c> is the full name of the file.</p>
            <p_zh>文件以所需的模式打开. <c><anno>IoDevice</anno></c> 文件的一个引用, <c><anno>FullName</anno></c> 是文件的完整路径.</p_zh>
          </item>
          <tag><c>{error, enoent}</c></tag>
          <item>
            <p>The file could not be found in any of the directories in
              <c><anno>Path</anno></c>.</p>
            <p_zh>列表<c><anno>Path</anno></c>里所有的文件夹中都未找到目标文件.</p_zh>
          </item>
          <tag><c>{error, atom()}</c></tag>
          <item>
            <p>The file could not be opened.</p>
            <p_zh>无法打开文件.</p_zh>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="path_script" arity="2"/>
      <fsummary>Evaluate and return the value of Erlang expressions in a file</fsummary>
      <desc>
        <p>Searches the path <c><anno>Path</anno></c> (a list of directory
          names) until the file <c><anno>Filename</anno></c> is found.
          If <c><anno>Filename</anno></c> is an absolute file name,
          <c><anno>Path</anno></c> is ignored. Then reads
          and evaluates Erlang expressions, separated by '.' (or ',', a
          sequence of expressions is also an expression), from the file.
          Returns one of the following:</p>
        <taglist>
          <tag><c>{ok, <anno>Value</anno>, <anno>FullName</anno>}</c></tag>
          <item>
            <p>The file was read and evaluated. <c><anno>FullName</anno></c> is
              the full name of the file and <c><anno>Value</anno></c> the value of
              the last expression.</p>
            <p_zh>读取文件并求值. <c><anno>FullName</anno></c> is the full name of the file and <c><anno>Value</anno></c> the value of
              the last expression.</p_zh>
          </item>
          <tag><c>{error, enoent}</c></tag>
          <item>
            <p>The file could not be found in any of the directories in
              <c><anno>Path</anno></c>.</p>
            <p_zh>列表<c><anno>Path</anno></c>里所有的文件夹中都未找到目标文件.</p_zh>
          </item>
          <tag><c>{error, atom()}</c></tag>
          <item>
            <p>An error occurred when opening the file or reading it.
              See <seealso marker="#open/2">open/2</seealso> for a list
              of typical error codes.</p>
            <p_zh>在打开或者读取文件的时候发生一个错误. 参阅 <seealso marker="#open/2">open/2</seealso> 中的典型错误代码列表.</p_zh>
          </item>
          <tag><c>{error, {<anno>Line</anno>, <anno>Mod</anno>,
                           <anno>Term</anno>}}</c></tag>
          <item>
            <p>An error occurred when interpreting the Erlang
              expressions in the file. Use <c>format_error/1</c> to
              convert the three-element tuple to an English description
              of the error.</p>
            <p_zh>当翻译文件中的Erlang项时发生一个错误. 使用<c>format_error/1</c>来将三元素的元组翻译成错误的英文描述.</p_zh>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="path_script" arity="3"/>
      <fsummary>Evaluate and return the value of Erlang expressions in a file</fsummary>
      <desc>
        <p>The same as <c>path_script/2</c> but the variable bindings
          <c><anno>Bindings</anno></c> are used in the evaluation. See
          <seealso marker="stdlib:erl_eval">erl_eval(3)</seealso> about
          variable bindings.</p>
      </desc>
    </func>
    <func>
      <name name="pid2name" arity="1"/>
      <fsummary>Return the name of the file handled by a pid</fsummary>
      <desc>
        <p>If <c><anno>Pid</anno></c> is an IO device, that is, a pid returned from
          <c>open/2</c>, this function returns the filename, or rather:</p>
        <p_zh>如果<c><anno>Pid</anno></c> 是一个IO设备, 也就是说该进程号是由<c>open/2</c>返回的, 该函数返回相应的文件名, 更确切的是:</p_zh>
        <taglist>
          <tag><c>{ok, <anno>Filename</anno>}</c></tag>
          <item>
            <p>If this node's file server is not a slave, the file was
              opened by this node's file server, (this implies that
              <c><anno>Pid</anno></c> must be a local pid) and the file is not
              closed. <c><anno>Filename</anno></c> is the filename in flat string
              format.</p>
            <p_zh>如果该节点的文件服务器不是"slave", 文件由该节点的文件服务器打开, (暗指<c><anno>Pid</anno></c> 必须是本地进程号) 并且文件没有关闭. <c><anno>Filename</anno></c> 是平坦化的字符串文件名.</p_zh>
          </item>
          <tag><c>undefined</c></tag>
          <item>
            <p>In all other cases.</p>
            <p_zh>其它情况.</p_zh>
          </item>
        </taglist>
        <warning>
          <p>This function is intended for debugging only.</p>
          <p_zh>设计该函数只是用于调试.</p_zh>
        </warning>
      </desc>
    </func>
    <func>
      <name name="position" arity="2"/>
      <fsummary>Set position in a file</fsummary>
      <desc>
        <p>Sets the position of the file referenced by <c><anno>IoDevice</anno></c>
          to <c><anno>Location</anno></c>. Returns
          <c>{ok, <anno>NewPosition</anno>}</c> (as
          absolute offset) if successful, otherwise
          <c>{error, <anno>Reason</anno>}</c>. <c><anno>Location</anno></c> is
          one of the following:</p>
        <p_zh>设置<c><anno>IoDevice</anno></c>引用的文件指针位置为<c><anno>Location</anno></c>.  如果成功的话返回<c>{ok, <anno>NewPosition</anno>}</c> (绝对文件偏移量), 否则返回<c>{error, <anno>Reason</anno>}</c>. <c><anno>Location</anno></c>为下列之一:</p_zh>
        <taglist>
          <tag><c>Offset</c></tag>
          <item>
            <p>The same as <c>{bof, Offset}</c>.</p>
            <p_zh>等同于<c>{bof, Offset}</c>.</p_zh>
          </item>
          <tag><c>{bof, Offset}</c></tag>
          <item>
            <p>Absolute offset.</p>
            <p_zh>绝对偏移量.</p_zh>
          </item>
          <tag><c>{cur, Offset}</c></tag>
          <item>
            <p>Offset from the current position.</p>
            <p_zh>相对当前位置的偏移量.</p_zh>
          </item>
          <tag><c>{eof, Offset}</c></tag>
          <item>
            <p>Offset from the end of file.</p>
            <p_zh>相对文件结尾的偏移量.</p_zh>
          </item>
          <tag><c>bof | cur | eof</c></tag>
          <item>
            <p>The same as above with <c>Offset</c> 0.</p>
            <p_zh>与以上相同，但<c>Offset</c> 为0.</p_zh>
          </item>
        </taglist>
	<p>Note that offsets are counted in bytes, not in characters. If the file is opened using some other <c>encoding</c> than <c>latin1</c>, one byte does not correspond to one character. Positioning in such a file can only be done to known character boundaries, i.e. to a position earlier retrieved by getting a current position, to the beginning/end of the file or to some other position <em>known</em> to be on a correct character boundary by some other means (typically beyond a byte order mark in the file, which has a known byte-size).</p>
	<p_zh>注意, 偏移量的单位是字节而不是字符. 如果文件以其他的<c>encoding</c> 而不是<c>latin1</c>打开时, 一个字节并不对应一个字符. Positioning in such a file can only be done to known character boundaries, i.e. to a position earlier retrieved by getting a current position, to the beginning/end of the file or to some other position <em>known</em> to be on a correct character boundary by some other means (typically beyond a byte order mark in the file, which has a known byte-size).</p_zh>
        <p>Typical error reasons are:</p>
        <p_zh>典型的错误原因:</p_zh>
        <taglist>
          <tag><c>einval</c></tag>
          <item>
            <p>Either <c><anno>Location</anno></c> was illegal, or it
              evaluated to a
              negative offset in the file. Note that if the resulting
              position is a negative value, the result is an error, and
              after the call the file position is undefined.</p>
            <p_zh><c><anno>Location</anno></c> 不合法或者计算出一个文件的负偏移量
              negative offset in the file. Note that if the resulting
              position is a negative value, the result is an error, and
              after the call the file position is undefined.</p_zh>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="pread" arity="2"/>
      <fsummary>Read from a file at certain positions</fsummary>
      <desc>
        <p>Performs a sequence of <c>pread/3</c> in one operation, 
          which is more efficient than calling them one at a time.
          Returns <c>{ok, [<anno>Data</anno>, ...]}</c> or
          <c>{error, <anno>Reason</anno>}</c>,
          where each <c><anno>Data</anno></c>, the result of the corresponding
          <c>pread</c>, is either a list or a binary depending on
          the mode of the file, or <c>eof</c> if the requested position
          was beyond end of file.</p>
	  <p>As the position is given as a byte-offset, special caution has to be taken when working with files where <c>encoding</c> is set to something else than <c>latin1</c>, as not every byte position will be a valid character boundary on such a file.</p>
      </desc>
    </func>
    <func>
      <name name="pread" arity="3"/>
      <fsummary>Read from a file at a certain position</fsummary>
      <desc>
        <p>Combines <c>position/2</c> and <c>read/2</c> in one
          operation, which is more efficient than calling them one at a
          time. If <c><anno>IoDevice</anno></c> has been opened in raw mode,
          some restrictions apply: <c><anno>Location</anno></c> is only allowed
          to be an
          integer; and the current position of the file is undefined
          after the operation.</p>
	  <p>As the position is given as a byte-offset, special caution has to be taken when working with files where <c>encoding</c> is set to something else than <c>latin1</c>, as not every byte position will be a valid character boundary on such a file.</p>
        </desc>
    </func>
    <func>
      <name name="pwrite" arity="2"/>
      <fsummary>Write to a file at certain positions</fsummary>
      <desc>
        <p>Performs a sequence of <c>pwrite/3</c> in one operation, 
          which is more efficient than calling them one at a time.
          Returns <c>ok</c> or <c>{error, {<anno>N</anno>,
          <anno>Reason</anno>}}</c>, where
          <c><anno>N</anno></c> is the number of successful writes that was done
          before the failure.</p>
	<p>When positioning in a file with other <c>encoding</c> than <c>latin1</c>, caution must be taken to set the position on a correct character boundary, see <seealso marker="#position/2">position/2</seealso> for details.</p>
      </desc>
    </func>
    <func>
      <name name="pwrite" arity="3"/>
      <fsummary>Write to a file at a certain position</fsummary>
      <desc>
        <p>Combines <c>position/2</c> and <c>write/2</c> in one
          operation, which is more efficient than calling them one at a
          time. If <c><anno>IoDevice</anno></c> has been opened in raw mode,
          some restrictions apply: <c><anno>Location</anno></c> is only allowed
          to be an
          integer; and the current position of the file is undefined
          after the operation.</p>
	<p>When positioning in a file with other <c>encoding</c> than <c>latin1</c>, caution must be taken to set the position on a correct character boundary, see <seealso marker="#position/2">position/2</seealso> for details.</p>
      </desc>
    </func>
    <func>
      <name name="read" arity="2"/>
      <fsummary>Read from a file</fsummary>
      <desc>
        <p>Reads <c><anno>Number</anno></c> bytes/characters from the file
          referenced by <c><anno>IoDevice</anno></c>. The functions
          <c>read/2</c>, <c>pread/3</c>
          and <c>read_line/1</c> are the only ways to read from a file
          opened in raw mode (although they work for normally opened
          files, too).</p>
	  <p>For files where <c>encoding</c> is set to something else than <c>latin1</c>, one character might be represented by more than one byte on the file. The parameter <c>Number</c> always denotes the number of <em>characters</em> read from the file, why the position in the file might be moved a lot more than this number when reading a Unicode file.</p>
	  <p>Also if <c>encoding</c> is set to something else than <c>latin1</c>, the <c>read/3</c> call will fail if the data contains characters larger than 255, why the <seealso marker="stdlib:io">io(3)</seealso> module is to be preferred when reading such a file.</p> 
	  <p>The function returns:</p>
        <taglist>
          <tag><c>{ok, <anno>Data</anno>}</c></tag>
          <item>
            <p>If the file was opened in binary mode, the read bytes are
              returned in a binary, otherwise in a list. The list or
              binary will be shorter than the number of bytes requested
              if end of file was reached.</p>
          </item>
          <tag><c>eof</c></tag>
          <item>
            <p>Returned if <c><anno>Number</anno>>0</c> and end of file was
              reached before anything at all could be read.</p>
          </item>
          <tag><c>{error, <anno>Reason</anno>}</c></tag>
          <item>
            <p>An error occurred.</p>
          </item>
        </taglist>
        <p>Typical error reasons:</p>
        <p_zh>典型的错误原因:</p_zh>
        <taglist>
          <tag><c>ebadf</c></tag>
          <item>
            <p>The file is not opened for reading.</p>
          </item>
          <tag><c>{no_translation, unicode, latin1}</c></tag>
          <item>
            <p>The file was opened with another <c>encoding</c> than <c>latin1</c> and the data in the file can not be translated to the byte-oriented data that this function returns.</p>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="read_file" arity="1"/>
      <fsummary>Read a file</fsummary>
      <desc>
        <p>Returns <c>{ok, <anno>Binary</anno>}</c>, where
          <c><anno>Binary</anno></c> is a binary
          data object that contains the contents of
          <c><anno>Filename</anno></c>, or
          <c>{error, <anno>Reason</anno>}</c> if an error occurs.</p>
        <p>Typical error reasons:</p>
        <p_zh>典型的错误原因:</p_zh>
        <taglist>
          <tag><c>enoent</c></tag>
          <item>
            <p>The file does not exist.</p>
          </item>
          <tag><c>eacces</c></tag>
          <item>
            <p>Missing permission for reading the file, or for
              searching one of the parent directories.</p>
          </item>
          <tag><c>eisdir</c></tag>
          <item>
            <p>The named file is a directory.</p>
          </item>
          <tag><c>enotdir</c></tag>
          <item>
            <p>A component of the file name is not a directory. On some
              platforms, <c>enoent</c> is returned instead.</p>
          </item>
          <tag><c>enomem</c></tag>
          <item>
            <p>There is not enough memory for the contents of the file.</p>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="read_file_info" arity="1"/>
      <name name="read_file_info" arity="2"/>
      <fsummary>Get information about a file</fsummary>
      <desc>
        <p>Retrieves information about a file. Returns
          <c>{ok, <anno>FileInfo</anno>}</c> if successful, otherwise
          <c>{error, <anno>Reason</anno>}</c>. <c><anno>FileInfo</anno></c>
          is a record
          <c>file_info</c>, defined in the Kernel include file
          <c>file.hrl</c>. Include the following directive in the module
          from which the function is called:</p>
        <code type="none">
-include_lib("kernel/include/file.hrl").</code>
		<p>The time type returned in <c>atime</c>, <c>mtime</c> and <c>ctime</c>
			is dependent on the time type set in <c>Opts :: {time, Type}</c>.
			Type <c>local</c> will return local time, <c>universal</c> will
			return universal time and <c>posix</c> will return seconds since
			or before unix time epoch which is 1970-01-01 00:00 UTC. 
			Default is <c>{time, local}</c>.
		</p> 
		<note>
          <p>
			  Since file times is stored in posix time on most OS it is
			  faster to query file information with the <c>posix</c> option.
		  </p> 
        </note>
        
        <p>The record <c>file_info</c> contains the following fields.</p>
        <taglist>
          <tag><c>size = integer()</c></tag>
          <item>
            <p>Size of file in bytes.</p>
          </item>
          <tag><c>type = device | directory | regular | other</c></tag>
          <item>
            <p>The type of the file.</p>
          </item>
          <tag><c>access = read | write | read_write | none</c></tag>
          <item>
            <p>The current system access to the file.</p>
          </item>
          <tag><c>atime = <seealso marker="#type-date_time">date_time()</seealso> | integer() </c></tag> 
          <item>
            <p>The last time the file was read.</p>
          </item>
          <tag><c>mtime = <seealso marker="#type-date_time">date_time()</seealso> | integer() </c></tag> 
          <item>
            <p>The last time the file was written.</p>
          </item>
          <tag><c>ctime = <seealso marker="#type-date_time">date_time()</seealso> | integer() </c></tag> 
          <item>
            <p>The interpretation of this time field depends on
              the operating system. On Unix, it is the last time
              the file or the inode was changed. In Windows, it is
              the create time.</p>
          </item>
          <tag><c>mode = integer()</c></tag>
          <item>
            <p>The file permissions as the sum of the following bit
              values:</p>
            <taglist>
              <tag>8#00400</tag>
              <item>read permission: owner</item>
              <tag>8#00200</tag>
              <item>write permission: owner</item>
              <tag>8#00100</tag>
              <item>execute permission: owner</item>
              <tag>8#00040</tag>
              <item>read permission: group</item>
              <tag>8#00020</tag>
              <item>write permission: group</item>
              <tag>8#00010</tag>
              <item>execute permission: group</item>
              <tag>8#00004</tag>
              <item>read permission: other</item>
              <tag>8#00002</tag>
              <item>write permission: other</item>
              <tag>8#00001</tag>
              <item>execute permission: other</item>
              <tag>16#800</tag>
              <item>set user id on execution</item>
              <tag>16#400</tag>
              <item>set group id on execution</item>
            </taglist>
            <p>On Unix platforms, other bits than those listed above
              may be set.</p>
          </item>
          <tag><c>links = integer()</c></tag>
          <item>
            <p>Number of links to the file (this will always be 1 for
              file systems which have no concept of links).</p>
          </item>
          <tag><c>major_device = integer()</c></tag>
          <item>
            <p>Identifies the file system where the file is located.
              In Windows, the number indicates a drive as follows:
              0 means A:, 1 means B:, and so on.</p>
          </item>
          <tag><c>minor_device = integer()</c></tag>
          <item>
            <p>Only valid for character devices on Unix. In all other
              cases, this field is zero.</p>
          </item>
          <tag><c>inode = integer()</c></tag>
          <item>
            <p>Gives the <c>inode</c> number. On non-Unix file systems,
              this field will be zero.</p>
          </item>
          <tag><c>uid = integer()</c></tag>
          <item>
            <p>Indicates the owner of the file. Will be zero for
              non-Unix file systems.</p>
          </item>
          <tag><c>gid = integer()</c></tag>
          <item>
            <p>Gives the group that the owner of the file belongs to.
              Will be zero for non-Unix file systems.</p>
          </item>
        </taglist>
        <p>Typical error reasons:</p>
        <p_zh>典型的错误原因:</p_zh>
        <taglist>
          <tag><c>eacces</c></tag>
          <item>
            <p>Missing search permission for one of the parent
              directories of the file.</p>
          </item>
          <tag><c>enoent</c></tag>
          <item>
            <p>The file does not exist.</p>
          </item>
          <tag><c>enotdir</c></tag>
          <item>
            <p>A component of the file name is not a directory. On some
              platforms, <c>enoent</c> is returned instead.</p>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="read_line" arity="1"/>
      <fsummary>Read a line from a file</fsummary>
      <desc>
        <p>Reads a line of bytes/characters from the file referenced by
          <c><anno>IoDevice</anno></c>. Lines are defined to be delimited by the linefeed (LF, <c>\n</c>) character, but any carriage return (CR, <c>\r</c>) followed by a newline is also treated as a single LF character (the carriage return is silently ignored). The line is returned <em>including</em> the LF, but excluding any CR immediately followed by a LF. This behaviour is consistent with the behaviour of <seealso marker="stdlib:io#get_line/2">io:get_line/2</seealso>. If end of file is reached without any LF ending the last line, a line with no trailing LF is returned.</p>
	  <p>The function can be used on files opened in <c>raw</c> mode. It is however inefficient to use it on <c>raw</c> files if the file is not opened with the option <c>{read_ahead, Size}</c> specified, why combining <c>raw</c> and <c>{read_ahead, Size}</c> is highly recommended when opening a text file for raw line oriented reading.</p> 
	  <p>If <c>encoding</c> is set to something else than <c>latin1</c>, the <c>read_line/1</c> call will fail if the data contains characters larger than 255, why the <seealso marker="stdlib:io">io(3)</seealso> module is to be preferred when reading such a file.</p> 
	  <p>The function returns:</p>
        <taglist>
          <tag><c>{ok, <anno>Data</anno>}</c></tag>
          <item>
	    <p>One line from the file is returned, including the trailing LF, but with CRLF sequences replaced by a single LF (see above).</p>
            <p>If the file was opened in binary mode, the read bytes are
              returned in a binary, otherwise in a list.</p>
          </item>
          <tag><c>eof</c></tag>
          <item>
            <p>Returned if end of file was reached
              before anything at all could be read.</p>
          </item>
          <tag><c>{error, <anno>Reason</anno>}</c></tag>
          <item>
            <p>An error occurred.</p>
          </item>
        </taglist>
        <p>Typical error reasons:</p>
        <p_zh>典型的错误原因:</p_zh>
        <taglist>
          <tag><c>ebadf</c></tag>
          <item>
            <p>The file is not opened for reading.</p>
          </item>
          <tag><c>{no_translation, unicode, latin1}</c></tag>
          <item>
            <p>The file is was opened with another <c>encoding</c> than <c>latin1</c> and the data on the file can not be translated to the byte-oriented data that this function returns.</p>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="read_link" arity="1"/>
      <fsummary>See what a link is pointing to</fsummary>
      <desc>
        <p>This function returns <c>{ok, <anno>Filename</anno>}</c> if
          <c><anno>Name</anno></c> refers to a symbolic link or
          <c>{error, <anno>Reason</anno>}</c> otherwise.
          On platforms that do not support symbolic links, the return
          value will be <c>{error,enotsup}</c>.</p>
        <p>Typical error reasons:</p>
        <p_zh>典型的错误原因:</p_zh>
        <taglist>
          <tag><c>einval</c></tag>
          <item>
            <p><c><anno>Name</anno></c> does not refer to a symbolic link.</p>
          </item>
          <tag><c>enoent</c></tag>
          <item>
            <p>The file does not exist.</p>
          </item>
          <tag><c>enotsup</c></tag>
          <item>
            <p>Symbolic links are not supported on this platform.</p>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="read_link_info" arity="1"/>
      <name name="read_link_info" arity="2"/>
      <fsummary>Get information about a link or file</fsummary>
      <desc>
		  <p>This function works like 
			 <seealso marker="#read_file_info/2">read_file_info/1,2</seealso> except that
          if <c><anno>Name</anno></c> is a symbolic link, information about
          the link will be returned in the <c>file_info</c> record and
          the <c>type</c> field of the record will be set to
          <c>symlink</c>.</p>
        <p>If <c><anno>Name</anno></c> is not a symbolic link, this function returns
          exactly the same result as <c>read_file_info/1</c>.
          On platforms that do not support symbolic links, this function
          is always equivalent to <c>read_file_info/1</c>.</p>
      </desc>
    </func>
    <func>
      <name name="rename" arity="2"/>
      <fsummary>Rename a file</fsummary>
      <desc>
        <p>Tries to rename the file <c><anno>Source</anno></c> to
          <c><anno>Destination</anno></c>.
          It can be used to move files (and directories) between
          directories, but it is not sufficient to specify
          the destination only. The destination file name must also be
          specified. For example, if <c>bar</c> is a normal file and
          <c>foo</c> and <c>baz</c> are directories,
          <c>rename("foo/bar", "baz")</c> returns an error, but
          <c>rename("foo/bar", "baz/bar")</c> succeeds. Returns
          <c>ok</c> if it is successful.</p>
        <note>
          <p>Renaming of open files is not allowed on most platforms
            (see <c>eacces</c> below).</p>
        </note>
        <p>Typical error reasons:</p>
        <p_zh>典型的错误原因:</p_zh>
        <taglist>
          <tag><c>eacces</c></tag>
          <item>
            <p>Missing read or write permissions for the parent
              directories of <c><anno>Source</anno></c> or
              <c><anno>Destination</anno></c>. On
              some platforms, this error is given if either
              <c><anno>Source</anno></c> or <c><anno>Destination</anno></c>
              is open.</p>
          </item>
          <tag><c>eexist</c></tag>
          <item>
            <p><c><anno>Destination</anno></c> is not an empty directory.
              On some platforms, also given when <c><anno>Source</anno></c> and
              <c><anno>Destination</anno></c> are not of the same type.</p>
          </item>
          <tag><c>einval</c></tag>
          <item>
            <p><c><anno>Source</anno></c> is a root directory, or
              <c><anno>Destination</anno></c>
              is a sub-directory of <c><anno>Source</anno></c>.</p>
          </item>
          <tag><c>eisdir</c></tag>
          <item>
            <p><c><anno>Destination</anno></c> is a directory, but
              <c><anno>Source</anno></c> is not.</p>
          </item>
          <tag><c>enoent</c></tag>
          <item>
            <p><c>Source</c> does not exist.</p>
          </item>
          <tag><c>enotdir</c></tag>
          <item>
            <p><c><anno>Source</anno></c> is a directory, but
              <c><anno>Destination</anno></c> is not.</p>
          </item>
          <tag><c>exdev</c></tag>
          <item>
            <p><c><anno>Source</anno></c> and <c><anno>Destination</anno></c>
              are on different file systems.</p>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="script" arity="1"/>
      <fsummary>Evaluate and return the value of Erlang expressions in a file</fsummary>
      <desc>
        <p>Reads and evaluates Erlang expressions, separated by '.' (or
          ',', a sequence of expressions is also an expression), from
          the file. Returns one of the following:</p>
        <taglist>
          <tag><c>{ok, <anno>Value</anno>}</c></tag>
          <item>
            <p>The file was read and evaluated. <c><anno>Value</anno></c> is
              the value of the last expression.</p>
          </item>
          <tag><c>{error, atom()}</c></tag>
          <item>
            <p>An error occurred when opening the file or reading it.
              See <seealso marker="#open/2">open/2</seealso> for a list
              of typical error codes.</p>
          </item>
          <tag><c>{error, {<anno>Line</anno>, <anno>Mod</anno>,
                           <anno>Term</anno>}}</c></tag>
          <item>
            <p>An error occurred when interpreting the Erlang
              expressions in the file. Use <c>format_error/1</c> to
              convert the three-element tuple to an English description
              of the error.</p>
            <p_zh>当翻译文件中的Erlang项时发生一个错误. 使用<c>format_error/1</c>来将三元素的元组翻译成错误的英文描述.</p_zh>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="script" arity="2"/>
      <fsummary>Evaluate and return the value of Erlang expressions in a file</fsummary>
      <desc>
        <p>The same as <c>script/1</c> but the variable bindings
          <c><anno>Bindings</anno></c> are used in the evaluation. See
          <seealso marker="stdlib:erl_eval">erl_eval(3)</seealso> about
          variable bindings.</p>
      </desc>
    </func>
    <func>
      <name name="set_cwd" arity="1"/>
      <fsummary>Set the current working directory</fsummary>
      <desc>
        <p>Sets the current working directory of the file server to
          <c><anno>Dir</anno></c>. Returns <c>ok</c> if successful.</p>
        <p>Typical error reasons are:</p>
        <p_zh>典型的错误原因:</p_zh>
        <taglist>
          <tag><c>enoent</c></tag>
          <item>
            <p>The directory does not exist.</p>
          </item>
          <tag><c>enotdir</c></tag>
          <item>
            <p>A component of <c><anno>Dir</anno></c> is not a directory.
              On some platforms, <c>enoent</c> is returned.</p>
          </item>
          <tag><c>eacces</c></tag>
          <item>
            <p>Missing permission for the directory or one of its
              parents.</p>
          </item>
          <tag><c>badarg</c></tag>
          <item>
            <p><c><anno>Dir</anno></c> had an improper type,
              such as tuple.</p>
          </item>
        </taglist>
        <warning>
          <p>In a future release, a bad type for the
            <c><anno>Dir</anno></c>
            argument will probably generate an exception.</p>
        </warning>
      </desc>
    </func>
    <func>
      <name name="sync" arity="1"/>
      <fsummary>Synchronizes the in-memory state of a file with that on the physical medium</fsummary>
      <desc>
        <p>Makes sure that any buffers kept by the operating system
          (not by the Erlang runtime system) are written to disk. On
          some platforms, this function might have no effect.</p>
        <p>Typical error reasons are:</p>
        <p_zh>典型的错误原因:</p_zh>
        <taglist>
          <tag><c>enospc</c></tag>
          <item>
            <p>Not enough space left to write the file.</p>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="datasync" arity="1"/>
      <fsummary>Synchronizes the in-memory data of a file, ignoring most of its metadata, with that on the physical medium</fsummary>
      <desc>
        <p>Makes sure that any buffers kept by the operating system
          (not by the Erlang runtime system) are written to disk. In
          many ways it's resembles fsync but it not requires to update
          some of file's metadata such as the access time. On
          some platforms, this function might have no effect.</p>
        <p>Applications that access databases or log files often write
          a tiny data fragment (e.g., one line in a log file) and then
          call fsync() immediately in order to ensure that the written
          data is physically stored on the harddisk. Unfortunately, fsync()
          will always initiate two write operations: one for the newly
          written data and another one in order to update the modification
          time stored in the inode. If the modification time is not a part
          of the transaction concept fdatasync() can be used to avoid
          unnecessary inode disk write operations.</p>
        <p>Available only in some POSIX systems. This call results in a
          call to fsync(), or has no effect, in systems not implementing
          the fdatasync syscall.</p>
      </desc>
    </func>
    <func>
      <name name="truncate" arity="1"/>
      <fsummary>Truncate a file</fsummary>
      <desc>
        <p>Truncates the file referenced by <c><anno>IoDevice</anno></c> at
          the current position.  Returns <c>ok</c> if successful,
          otherwise <c>{error, <anno>Reason</anno>}</c>.</p>
      </desc>
    </func>
    <func>
      <name name="sendfile" arity="2"/>
      <fsummary>send a file to a socket</fsummary>
      <desc>
        <p>Sends the file <c>Filename</c> to <c>Socket</c>.
        Returns <c>{ok, BytesSent}</c> if successful,
        otherwise <c>{error, Reason}</c>.</p>
      </desc>
    </func>
    <func>
      <name name="sendfile" arity="5"/>
      <fsummary>send a file to a socket</fsummary>
      <desc>
        <p>Sends <c>Bytes</c> from the file
        referenced by <c>RawFile</c> beginning at <c>Offset</c> to
        <c>Socket</c>.
        Returns <c>{ok, BytesSent}</c> if successful,
        otherwise <c>{error, Reason}</c>. If <c>Bytes</c> is set to
	0 all data after the given <c>Offset</c> is sent.</p>
	<p>The file used must be opened using the raw flag, and the process
	calling sendfile must be the controlling process of the socket.
	See <seealso marker="gen_tcp#controlling_process-2">gen_tcp:controlling_process/2</seealso></p>
	<p>If the OS used does not support sendfile, an Erlang fallback
	using file:read and gen_tcp:send is used.</p>
	<p>The option list can contain the following options:
	<taglist>
          <tag><c>chunk_size</c></tag>
          <item>The chunk size used by the erlang fallback to send
	  data. If using the fallback, this should be set to a value
	  which comfortably fits in the systems memory. Default is 20 MB.</item>
	</taglist>
	</p>
	<p>On operating systems with thread support, it is recommended to use
	async threads. See the command line flag
	<c>+A</c> in <seealso marker="erts:erl">erl(1)</seealso>. If it is not
	possible to use async threads for sendfile, it is recommended to use
	a relatively small value for the send buffer on the socket. Otherwise
	the Erlang VM might loose some of its soft realtime guarantees.
	Which size to use depends on the OS/hardware and the requirements
	of the application.</p>
      </desc>
    </func>
    <func>
      <name name="write" arity="2"/>
      <fsummary>Write to a file</fsummary>
      <desc>
        <p>Writes <c><anno>Bytes</anno></c> to the file referenced by
          <c><anno>IoDevice</anno></c>. This function is the only way to write to a
          file opened in raw mode (although it works for normally
          opened files, too). Returns <c>ok</c> if successful, and
          <c>{error, <anno>Reason</anno>}</c> otherwise.</p>
	  <p>If the file is opened with <c>encoding</c> set to something else than <c>latin1</c>, each byte written might result in several bytes actually being written to the file, as the byte range 0..255 might represent anything between one and four bytes depending on value and UTF encoding type.</p>
        <p>Typical error reasons are:</p>
        <p_zh>典型的错误原因:</p_zh>
        <taglist>
          <tag><c>ebadf</c></tag>
          <item>
            <p>The file is not opened for writing.</p>
          </item>
          <tag><c>enospc</c></tag>
          <item>
            <p>There is a no space left on the device.</p>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="write_file" arity="2"/>
      <fsummary>Write a file</fsummary>
      <desc>
        <p>Writes the contents of the iodata term <c><anno>Bytes</anno></c>
          to the file <c><anno>Filename</anno></c>.
          The file is created if it does not
          exist. If it exists, the previous contents are
          overwritten. Returns <c>ok</c>, or <c>{error, <anno>Reason</anno>}</c>.</p>
        <p>Typical error reasons are:</p>
        <p_zh>典型的错误原因:</p_zh>
        <taglist>
          <tag><c>enoent</c></tag>
          <item>
            <p>A component of the file name does not exist.</p>
          </item>
          <tag><c>enotdir</c></tag>
          <item>
            <p>A component of the file name is not a directory. On some
              platforms, <c>enoent</c> is returned instead.</p>
          </item>
          <tag><c>enospc</c></tag>
          <item>
            <p>There is a no space left on the device.</p>
          </item>
          <tag><c>eacces</c></tag>
          <item>
            <p>Missing permission for writing the file or searching one
              of the parent directories.</p>
          </item>
          <tag><c>eisdir</c></tag>
          <item>
            <p>The named file is a directory.</p>
          </item>
        </taglist>
      </desc>
    </func>
    <func>
      <name name="write_file" arity="3"/>
      <fsummary>Write a file</fsummary>
      <desc>
        <p>Same as <c>write_file/2</c>, but takes a third argument
          <c><anno>Modes</anno></c>, a list of possible modes, see
          <seealso marker="#open/2">open/2</seealso>. The mode flags
          <c>binary</c> and <c>write</c> are implicit, so they should
          not be used.</p>
      </desc>
    </func>
    <func>
      <name name="write_file_info" arity="2"/>
      <name name="write_file_info" arity="3"/>
      <fsummary>Change information about a file</fsummary>
      <desc>
        <p>Change file information. Returns <c>ok</c> if successful,
          otherwise <c>{error, <anno>Reason</anno>}</c>.
          <c><anno>FileInfo</anno></c> is a record
          <c>file_info</c>, defined in the Kernel include file
          <c>file.hrl</c>. Include the following directive in the module
          from which the function is called:</p>
        <code type="none">
-include_lib("kernel/include/file.hrl").</code>
		<p>The time type set in <c>atime</c>, <c>mtime</c> and <c>ctime</c>
			is dependent on the time type set in <c>Opts :: {time, Type}</c>.
			Type <c>local</c> will interpret the time set as local, <c>universal</c> will
			interpret it as universal time and <c>posix</c> must be seconds since
			or before unix time epoch which is 1970-01-01 00:00 UTC.
			Default is <c>{time, local}</c>.
		</p>
        <p>The following fields are used from the record, if they are
          given.</p>
        <taglist>
          <tag><c>atime = <seealso marker="#type-date_time">date_time()</seealso> | integer()</c></tag>
          <item>
            <p>The last time the file was read.</p>
          </item>
          <tag><c>mtime = <seealso marker="#type-date_time">date_time()</seealso> | integer()</c></tag>
          <item>
            <p>The last time the file was written.</p>
          </item>
          <tag><c>ctime = <seealso marker="#type-date_time">date_time()</seealso> | integer()</c></tag>
          <item>
            <p>On Unix, any value give for this field will be ignored
              (the "ctime" for the file will be set to the current
              time). On Windows, this field is the new creation time to
              set for the file.</p>
          </item>
          <tag><c>mode = integer()</c></tag>
          <item>
            <p>The file permissions as the sum of the following bit
              values:</p>
            <taglist>
              <tag>8#00400</tag>
              <item>read permission: owner</item>
              <tag>8#00200</tag>
              <item>write permission: owner</item>
              <tag>8#00100</tag>
              <item>execute permission: owner</item>
              <tag>8#00040</tag>
              <item>read permission: group</item>
              <tag>8#00020</tag>
              <item>write permission: group</item>
              <tag>8#00010</tag>
              <item>execute permission: group</item>
              <tag>8#00004</tag>
              <item>read permission: other</item>
              <tag>8#00002</tag>
              <item>write permission: other</item>
              <tag>8#00001</tag>
              <item>execute permission: other</item>
              <tag>16#800</tag>
              <item>set user id on execution</item>
              <tag>16#400</tag>
              <item>set group id on execution</item>
            </taglist>
            <p>On Unix platforms, other bits than those listed above
              may be set.</p>
          </item>
          <tag><c>uid = integer()</c></tag>
          <item>
            <p>Indicates the owner of the file. Ignored for non-Unix
              file systems.</p>
          </item>
          <tag><c>gid = integer()</c></tag>
          <item>
            <p>Gives the group that the owner of the file belongs to.
              Ignored non-Unix file systems.</p>
          </item>
        </taglist>
        <p>Typical error reasons:</p>
        <p_zh>典型的错误原因:</p_zh>
        <taglist>
          <tag><c>eacces</c></tag>
          <item>
            <p>Missing search permission for one of the parent
              directories of the file.</p>
          </item>
          <tag><c>enoent</c></tag>
          <item>
            <p>The file does not exist.</p>
          </item>
          <tag><c>enotdir</c></tag>
          <item>
            <p>A component of the file name is not a directory. On some
              platforms, <c>enoent</c> is returned instead.</p>
          </item>
        </taglist>
      </desc>
    </func>
  </funcs>

  <section>
    <title>POSIX Error Codes</title>
    <list type="bulleted">
      <item><c>eacces</c> - permission denied</item>
      <item><c>eagain</c> - resource temporarily unavailable</item>
      <item><c>ebadf</c> - bad file number</item>
      <item><c>ebusy</c> - file busy</item>
      <item><c>edquot</c> - disk quota exceeded</item>
      <item><c>eexist</c> - file already exists</item>
      <item><c>efault</c> - bad address in system call argument</item>
      <item><c>efbig</c> - file too large</item>
      <item><c>eintr</c> - interrupted system call</item>
      <item><c>einval</c> - invalid argument</item>
      <item><c>eio</c> - IO error</item>
      <item><c>eisdir</c> - illegal operation on a directory</item>
      <item><c>eloop</c> - too many levels of symbolic links</item>
      <item><c>emfile</c> - too many open files</item>
      <item><c>emlink</c> - too many links</item>
      <item><c>enametoolong</c> - file name too long</item>
      <item><c>enfile</c> - file table overflow</item>
      <item><c>enodev</c> - no such device</item>
      <item><c>enoent</c> - no such file or directory</item>
      <item><c>enomem</c> - not enough memory</item>
      <item><c>enospc</c> - no space left on device</item>
      <item><c>enotblk</c> - block device required</item>
      <item><c>enotdir</c> - not a directory</item>
      <item><c>enotsup</c> - operation not supported</item>
      <item><c>enxio</c> - no such device or address</item>
      <item><c>eperm</c> - not owner</item>
      <item><c>epipe</c> - broken pipe</item>
      <item><c>erofs</c> - read-only file system</item>
      <item><c>espipe</c> - invalid seek</item>
      <item><c>esrch</c> - no such process</item>
      <item><c>estale</c> - stale remote file handle</item>
      <item><c>exdev</c> - cross-domain link</item>
    </list>
  </section>

  <section>
    <title>Performance</title>
    <p>Some operating system file operations, for example a
      <c>sync/1</c> or <c>close/1</c> on a huge file, may block their 
      calling thread for seconds. If this befalls the emulator main
      thread, the response time is no longer in the order of
      milliseconds, depending on the definition of "soft" in soft
      real-time system.</p>
    <p>If the device driver thread pool is active, file operations are
      done through those threads instead, so the emulator can go on
      executing Erlang processes. Unfortunately, the time for serving a
      file operation increases due to the extra scheduling required
      from the operating system.</p>
    <p>If the device driver thread pool is disabled or of size 0, large
      file reads and writes are segmented into several smaller, which
      enables the emulator so server other processes during the file
      operation. This gives the same effect as when using the thread
      pool, but with larger overhead. Other file operations, for
      example <c>sync/1</c> or <c>close/1</c> on a huge file, still are
      a problem.</p>
    <p>For increased performance, raw files are recommended. Raw files
      uses the file system of the node's host machine. For normal files
      (non-raw), the file server is used to find the files, and if
      the node is running its file server as slave to another node's,
      and the other node runs on some other host machine, they may have
      different file systems. This is seldom a problem, but you have
      now been warned.</p>
    <p>A normal file is really a process so it can be used as an IO
      device (see <c>io</c>). Therefore when data is written to a
      normal file, the sending of the data to the file process, copies 
      all data that are not binaries. Opening the file in binary mode
      and writing binaries is therefore recommended. If the file is
      opened on another node, or if the file server runs as slave to
      another node's, also binaries are copied.</p>
    <p>Caching data to reduce the number of file operations, or rather
      the number of calls to the file driver, will generally increase
      performance. The following function writes 4 MBytes in 23
      seconds when tested:</p>
    <code type="none"><![CDATA[
create_file_slow(Name, N) when integer(N), N >= 0 ->
    {ok, FD} = file:open(Name, [raw, write, delayed_write, binary]),
    ok = create_file_slow(FD, 0, N),
    ok = ?FILE_MODULE:close(FD),
    ok.
      
create_file_slow(FD, M, M) ->
    ok;
create_file_slow(FD, M, N) ->
    ok = file:write(FD, <<M:32/unsigned>>),
    create_file_slow(FD, M+1, N).]]></code>
    <p>The following, functionally equivalent, function collects 1024
      entries into a list of 128 32-byte binaries before each call to
      <c>file:write/2</c> and so does the same work in 0.52 seconds,
      which is 44 times faster.</p>
    <code type="none"><![CDATA[
create_file(Name, N) when integer(N), N >= 0 ->
    {ok, FD} = file:open(Name, [raw, write, delayed_write, binary]),
    ok = create_file(FD, 0, N),
    ok = ?FILE_MODULE:close(FD),
    ok.
      
create_file(FD, M, M) ->
    ok;
create_file(FD, M, N) when M + 1024 =&lt; N ->
    create_file(FD, M, M + 1024, []),
    create_file(FD, M + 1024, N);
create_file(FD, M, N) ->
    create_file(FD, M, N, []).
      
create_file(FD, M, M, R) ->
    ok = file:write(FD, R);
create_file(FD, M, N0, R) when M + 8 =&lt; N0 ->
    N1  = N0-1,  N2  = N0-2,  N3  = N0-3,  N4  = N0-4, 
    N5  = N0-5,  N6  = N0-6,  N7  = N0-7,  N8  = N0-8, 
    create_file(FD, M, N8, 
                [<<N8:32/unsigned,  N7:32/unsigned, 
                   N6:32/unsigned,  N5:32/unsigned, 
                   N4:32/unsigned,  N3:32/unsigned, 
                   N2:32/unsigned,  N1:32/unsigned>> | R]);
create_file(FD, M, N0, R) ->
    N1 = N0-1,
    create_file(FD, M, N1, [<<N1:32/unsigned>> | R]).]]></code>
    <note>
      <p>Trust only your own benchmarks. If the list length in 
        <c>create_file/2</c> above is increased, it will run slightly
        faster, but consume more memory and cause more memory
        fragmentation. How much this affects your application is
        something that this simple benchmark can not predict.</p>
      <p>If the size of each binary is increased to 64 bytes, it will
        also run slightly faster, but the code will be twice as clumsy.
        In the current implementation are binaries larger than 64 bytes
        stored in memory common to all processes and not copied when
        sent between processes, while these smaller binaries are stored
        on the process heap and copied when sent like any other term.</p>
      <p>So, with a binary size of 68 bytes <c>create_file/2</c> runs
        30 percent slower then with 64 bytes, and will cause much more
        memory fragmentation. Note that if the binaries were to be sent
        between processes (for example a non-raw file) the results
        would probably be completely different.</p>
    </note>
    <p>A raw file is really a port. When writing data to a port, it is
      efficient to write a list of binaries. There is no need to
      flatten a deep list before writing. On Unix hosts, scatter output,
      which writes a set of buffers in one operation, is used when
      possible. In this way <c>file:write(FD, [Bin1, Bin2 | Bin3])</c>
      will write the contents of the binaries without copying the data
      at all except for perhaps deep down in the operating system
      kernel.</p>
    <p>For raw files, <c>pwrite/2</c> and <c>pread/2</c> are
      efficiently implemented. The file driver is called only once for
      the whole operation, and the list iteration is done in the file
      driver.</p>
    <p>The options <c>delayed_write</c> and <c>read_ahead</c> to 
      <c>file:open/2</c> makes the file driver cache data to reduce
      the number of operating system calls. The function
      <c>create_file/2</c> in the example above takes 60 seconds
      seconds without the <c>delayed_write</c> option, which is 2.6
      times slower.</p>
    <p>And, as a really bad example, <c>create_file_slow/2</c> above
      without the <c>raw</c>, <c>binary</c> and <c>delayed_write</c>
      options, that is it calls <c>file:open(Name, [write])</c>, needs
      1 min 20 seconds for the job, which is 3.5 times slower than
      the first example, and 150 times slower than the optimized
      <c>create_file/2</c>. </p>
  </section>

  <section>
    <title>Warnings</title>
    <p>If an error occurs when accessing an open file with the <c>io</c>
      module, the process which handles the file will exit. The dead
      file process might hang if a process tries to access it later.
      This will be fixed in a future release.</p>
    <p_zh>If an error occurs when accessing an open file with the <c>io</c>
      module, the process which handles the file will exit. The dead
      file process might hang if a process tries to access it later.
      This will be fixed in a future release.</p_zh>
  </section>

  <section>
    <title>SEE ALSO</title>
    <p><seealso marker="stdlib:filename">filename(3)</seealso></p>
  </section>
</erlref>

