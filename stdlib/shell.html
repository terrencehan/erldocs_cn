<!DOCTYPE html>
<html lang="en">

  <head>
      <meta charset="utf-8"/> 
    <title>erldos.cn--Erlang/OTP中文参考手册</title>
    <link type="text/css" rel="stylesheet" href="../stylesheets/main.css" />

    <link rel="search" type="application/opensearchdescription+xml"
          title="erldocs" href="/search.xml">

  </head>
  <body>

    <div id="sidebar" class="inactive">
      <input type="text" id="search" autocomplete="off"
             placeholder="press TAB to search" />
      <ul id="results"> </ul>
    </div>

    <div id="content">
        <div style="margin:0px; padding:10px 20px">
  <h1>shell</h1>
  <h2 class="modsummary">The Erlang Shell</h2>
  <div class="description">
    <p class="english">The module <code>shell</code> implements an Erlang shell.
      </p>
    <p><code>shell</code>模块实现了Erlang shell. </p>
    <p class="english">The shell is a user interface program 
      for entering expression sequences. The expressions are
      evaluated and a value is returned. 
      A history mechanism saves previous commands and their
      values, which can then be incorporated in later commands.
      How many commands and results to save can be determined by the user,
      either interactively, by calling <code>shell:history/1</code> and
      <code>shell:results/1</code>, or by setting the application configuration
      parameters <code>shell_history_length</code> and
      <code>shell_saved_results</code> for the application STDLIB.
      </p>
    <p class="english">The shell uses a helper process for evaluating commands in
      order to protect the history mechanism from exceptions. By
      default the evaluator process is killed when an exception
      occurs, but by calling <code>shell:catch_exception/1</code> or by
      setting the application configuration parameter
      <code>shell_catch_exception</code> for the application STDLIB
      this behavior can be changed. See also the example below.
      </p>
    <p class="english">Variable bindings, and local process dictionary changes
      which are generated in user expressions are preserved, and the variables
      can be used in later commands to access their values. The
      bindings can also be forgotten so the variables can be re-used.
      </p>
    <p class="english">The special shell commands all have the syntax of (local)
      function calls. They are evaluated as
      normal function calls and many commands can be used in one
      expression sequence.
      </p>
    <p class="english">If a command (local function call) is not recognized by the
      shell, an attempt is first made to find the function in the
      module <code>user_default</code>, where customized local commands
      can be placed. If found, then the function is evaluated.
      Otherwise, an attempt is made to evaluate the function in the
      module <code>shell_default</code>. The module
      <code>user_default</code> must be explicitly loaded.
      </p>
    <p class="english">The shell also permits the user to start multiple concurrent
      jobs. A job can be regarded as a set of processes which can
      communicate with the shell.
      </p>
    <p class="english">There is some support for reading and printing records in
      the shell. During compilation record expressions are translated
      to tuple expressions. In runtime it is not known whether a tuple
      actually represents a record. Nor are the record definitions
      used by compiler available at runtime. So in order to read the
      record syntax and print tuples as records when possible, record
      definitions have to be maintained by the shell itself. The shell
      commands for reading, defining, forgetting, listing, and
      printing records are described below. Note that each job has its
      own set of record definitions. To facilitate matters record
      definitions in the modules <code>shell_default</code> and
      <code>user_default</code> (if loaded) are read each time a new job is
      started. For instance, adding the line</p>
    <pre>
          -include_lib("kernel/include/file.hrl").</pre>
    <p class="english">to <code>user_default</code> makes the definition of <code>file_info</code>
      readily available in the shell.
      </p>
    <p class="english">The shell runs in two modes: </p>
    <list type="bulleted">
      <p class="english"><code>Normal (possibly restricted)</code> mode, in which
       commands can be edited and expressions evaluated.
      </p>
      <p class="english">Job Control Mode <code>JCL</code>, in which jobs can be
       started, killed, detached and connected.
      </p>
    </list>
    <p class="english">Only the currently connected job can 'talk' to the shell.</p>
  </div>
  <section>
    <h4>Shell Commands</h4>
    <div class="taglist">
      <dt>
        <code>b()</code>
      </dt>
      <p class="english">
        <p class="english">Prints the current variable bindings.</p>
        <p>打印当前的变量绑定.</p>
      </p>
      <dt>
        <code>f()</code>
      </dt>
      <p class="english">
        <p class="english">Removes all variable bindings.
          </p>
        <p>移除所有变量绑定.
          </p>
      </p>
      <dt>
        <code>f(X)</code>
      </dt>
      <p class="english">
        <p class="english">Removes the binding of variable <code>X</code>.
          </p>
        <p>移除变量<code>X</code>的绑定.
          </p>
      </p>
      <dt>
        <code>h()</code>
      </dt>
      <p class="english">
        <p class="english">Prints the history list.
          </p>
        <p>打印历史列表.
          </p>
      </p>
      <dt>
        <code>history(N)</code>
      </dt>
      <p class="english">
        <p class="english">Sets the number of previous commands to keep in the
          history list to <code>N</code>. The previous number is returned.
          The default number is 20.
          </p>
        <p>将保存在历史列表中"之前命令"(相对于此命令)的数量设置为<code>N</code>. 返回修改之前的数值. 默认值为20.  </p>
      </p>
      <dt>
        <code>results(N)</code>
      </dt>
      <p class="english">
        <p class="english">Sets the number of results from previous commands to keep in
          the history list to <code>N</code>. The previous number is returned.
          The default number is 20.
          </p>
        <p>将保存在历史列表中"之前命令"(相对于此命令)的结果数量设置为<code>N</code>. 返回修改之前的数值. 默认值为20.  </p>
      </p>
      <dt>
        <code>e(N)</code>
      </dt>
      <p class="english">
        <p class="english">Repeats the command <code>N</code>, if <code>N</code> is positive. If
          it is negative, the <code>N</code>th previous command is repeated
          (i.e., <code>e(-1)</code> repeats the previous command).
          </p>
        <p>如果<code>N</code>是整数, 重复命令<code>N</code>. 如果为负, 重复前第<code>N</code>条命令 (例如, <code>e(-1)</code> 重复先前一条命令).
          </p>
      </p>
      <dt>
        <code>v(N)</code>
      </dt>
      <p class="english">
        <p class="english">Uses the return value of the command <code>N</code> in the
          current command, if <code>N</code> is positive. If it is negative,
          the return value of the <code>N</code>th previous command is used
          (i.e., <code>v(-1)</code> uses the value of the previous command).
          </p>
      </p>
      <dt>
        <code>help()</code>
      </dt>
      <p class="english">
        <p class="english">Evaluates <code>shell_default:help()</code>.
          </p>
        <p>执行<code>shell_default:help()</code>.
          </p>
      </p>
      <dt>
        <code>c(File)</code>
      </dt>
      <p class="english">
        <p class="english">Evaluates <code>shell_default:c(File)</code>. This compiles
          and loads code in <code>File</code> and purges old versions of
          code, if necessary. Assumes that the file and module names
          are the same.
          </p>
      </p>
      <dt>
        <code>catch_exception(Bool)</code>
      </dt>
      <p class="english">
        <p class="english">Sets the exception handling of the evaluator process. The
          previous exception handling is returned. The default
          (<code>false</code>) is to kill the evaluator process when an
          exception occurs, which causes the shell to create a new
          evaluator process. When the exception handling is set to
          <code>true</code> the evaluator process lives on which means that
          for instance ports and ETS tables as well as processes
          linked to the evaluator process survive the exception.
        </p>
      </p>
      <dt>
        <code>rd(RecordName, RecordDefinition)</code>
      </dt>
      <p class="english">
        <p class="english">Defines a record in the shell. <code>RecordName</code> is
          an atom and <code>RecordDefinition</code> lists the field names
          and the default values. Usually record definitions are made
          known to the shell by use of the <code>rr</code> commands
          described below, but sometimes it is handy to define records
          on the fly.
          </p>
      </p>
      <dt>
        <code>rf()</code>
      </dt>
      <p class="english">
        <p class="english">Removes all record definitions, then reads record
          definitions from the modules <code>shell_default</code> and
          <code>user_default</code> (if loaded). Returns the names of the
          records defined.
          </p>
      </p>
      <dt>
        <code>rf(RecordNames)</code>
      </dt>
      <p class="english">
        <p class="english">Removes selected record definitions.
          <code>RecordNames</code> is a record name or a list of record names.
          Use <code>'_'</code> to remove all record definitions.
          </p>
      </p>
      <dt>
        <code>rl()</code>
      </dt>
      <p class="english">
        <p class="english">Prints all record definitions.
          </p>
      </p>
      <dt>
        <code>rl(RecordNames)</code>
      </dt>
      <p class="english">
        <p class="english">Prints selected record definitions.
          <code>RecordNames</code> is a record name or a list of record names.
          </p>
      </p>
      <dt>
        <code>rp(Term)</code>
      </dt>
      <p class="english">
        <p class="english">Prints a term using the record definitions known to the
          shell. All of <code>Term</code> is printed; the depth is not
          limited as is the case when a return value is printed.
          </p>
      </p>
      <dt>
        <code>rr(Module)</code>
      </dt>
      <p class="english">
        <p class="english">Reads record definitions from a module's BEAM file. If
          there are no record definitions in the BEAM file, the
          source file is located and read instead. Returns the names
          of the record definitions read. <code>Module</code> is an atom.
          </p>
      </p>
      <dt>
        <code>rr(Wildcard)</code>
      </dt>
      <p class="english">
        <p class="english">Reads record definitions from files. Existing
          definitions of any of the record names read are replaced.
          <code>Wildcard</code> is a wildcard string as defined in
          <code>filelib(3)</code> but not an atom.
          </p>
      </p>
      <dt>
        <code>rr(WildcardOrModule, RecordNames)</code>
      </dt>
      <p class="english">
        <p class="english">Reads record definitions from files but
          discards record names not mentioned in <code>RecordNames</code> (a
          record name or a list of record names).
          </p>
      </p>
      <dt>
        <code>rr(WildcardOrModule, RecordNames, Options)</code>
      </dt>
      <p class="english">
        <p class="english">Reads record definitions from files. The compiler
          options <code>{i,&nbsp;Dir}</code>, <code>{d,&nbsp;Macro}</code>, and
          <code>{d,&nbsp;Macro,&nbsp;Value}</code> are recognized and used
          for setting up the include path and macro definitions. Use
          <code>'_'</code> as value of <code>RecordNames</code> to read all record
          definitions.
          </p>
      </p>
    </div>
  </section>
  <section>
    <h4>Example</h4>
    <p class="english">The following example is a long dialogue with the shell. Commands
      starting with <code>></code> are inputs to the shell. All other lines
      are output from the shell. All commands in this example are explained at the end of the dialogue.
      .</p>
    <pre>
strider 1> <span>erl</span>
Erlang (BEAM) emulator version 5.3 [hipe] [threads:0]

Eshell V5.3  (abort with ^G)
1><span>Str = "abcd".</span>
"abcd"
2> <span>L = length(Str).</span>
4
3> <span>Descriptor = {L, list_to_atom(Str)}.</span>
{4,abcd}
4> <span>L.</span> 
4
5> <span>b().</span>
Descriptor = {4,abcd}
L = 4
Str = "abcd"
ok
6> <span>f(L).</span> 
ok
7> <span>b().</span>
Descriptor = {4,abcd}
Str = "abcd"
ok
8> <span>f(L).</span>
ok
9> <span>{L, _} = Descriptor.</span>
{4,abcd}
10> <span>L.</span>
4
11> <span>{P, Q, R} = Descriptor.</span>
** exception error: no match of right hand side value {4,abcd}
12> <span>P.</span>
* 1: variable 'P' is unbound **
13> <span>Descriptor.</span>
{4,abcd}
14><span>{P, Q} = Descriptor.</span>
{4,abcd}
15> <span>P.</span>
4
16> <span>f().</span>
ok
17> <span>put(aa, hello).</span>
undefined
18> <span>get(aa).</span>
hello
19> <span>Y = test1:demo(1).</span>
11
20> <span>get().</span>
[{aa,worked}]
21> <span>put(aa, hello).</span>
worked
22> <span>Z = test1:demo(2).</span>
** exception error: no match of right hand side value 1
     in function  test1:demo/1
23> <span>Z.</span>
* 1: variable 'Z' is unbound **
24> <span>get(aa).</span>
hello
25> <span>erase(), put(aa, hello).</span>
undefined
26> <span>spawn(test1, demo, [1]).</span>
&lt;0.57.0>
27> <span>get(aa).</span>
hello
28> <span>io:format("hello hello\n").</span>
hello hello
ok
29> <span>e(28).</span>
hello hello
ok
30> <span>v(28).</span>
ok
31> <span>c(ex).</span>
{ok,ex}
32> <span>rr(ex).</span>
[rec]
33> <span>rl(rec).</span>
-record(rec,{a,b = val()}).
ok
34> <span>#rec{}.</span>
** exception error: undefined shell command val/0
35> <span>#rec{b = 3}.</span>
#rec{a = undefined,b = 3}
36> <span>rp(v(-1)).</span>
#rec{a = undefined,b = 3}
ok
37> <span>rd(rec, {f = orddict:new()}).</span>
rec
38> <span>#rec{}.</span>
#rec{f = []}
ok
39> <span>rd(rec, {c}), A.</span>
* 1: variable 'A' is unbound **
40> <span>#rec{}.</span>
#rec{c = undefined}
ok
41> <span>test1:loop(0).</span>
Hello Number: 0
Hello Number: 1
Hello Number: 2
Hello Number: 3

User switch command
 --> i
 --> c
.
.
.
Hello Number: 3374
Hello Number: 3375
Hello Number: 3376
Hello Number: 3377
Hello Number: 3378
** exception exit: killed
42> <span>E = ets:new(t, []).</span>
17
43> <span>ets:insert({d,1,2}).</span>
** exception error: undefined function ets:insert/1
44> <span>ets:insert(E, {d,1,2}).</span>
** exception error: argument is of wrong type
     in function  ets:insert/2
        called as ets:insert(16,{d,1,2})
45> <span>f(E).</span>
ok
46> <span>catch_exception(true).</span>
false
47> <span>E = ets:new(t, []).</span>
18
48> <span>ets:insert({d,1,2}).</span>
* exception error: undefined function ets:insert/1
49> <span>ets:insert(E, {d,1,2}).</span>
true
50> <span>halt().</span>
strider 2></pre>
  </section>
  <section>
    <h4>Comments</h4>
    <p class="english">Command 1 sets the variable <code>Str</code> to the string
      <code>"abcd"</code>.
      </p>
    <p class="english">Command 2 sets <code>L</code> to the length of the string evaluating
      the BIF <code>atom_to_list</code>.
      </p>
    <p class="english">Command 3 builds the tuple <code>Descriptor</code>.
      </p>
    <p class="english">Command 4 prints the value of the variable <code>L</code>.
      </p>
    <p class="english">Command 5 evaluates the internal shell command <code>b()</code>, which
      is an abbreviation of "bindings". This prints 
      the current shell variables and their bindings. The <code>ok</code> at
      the end is the return value of the <code>b()</code> function.
      </p>
    <p class="english">Command 6 <code>f(L)</code> evaluates the internal shell command
      <code>f(L)</code> (abbreviation of "forget"). The value of the variable
      <code>L</code> is removed.
      </p>
    <p class="english">Command 7 prints the new bindings.
      </p>
    <p class="english">Command 8 has no effect since <code>L</code> has no value.</p>
    <p class="english">Command 9 performs a pattern matching operation on
      <code>Descriptor</code>, binding a new value to <code>L</code>.
      </p>
    <p class="english">Command 10 prints the current value of <code>L</code>.
      </p>
    <p class="english">Command 11 tries to match <code>{P, Q, R}</code> against
      <code>Descriptor</code> which is <code>{4, abc}</code>. The match fails and
      none of the new variables become bound. The printout starting
      with "<code>** exception error:</code>" is not the value of the
      expression (the expression had no value because its evaluation
      failed), but rather a warning printed by the system to inform
      the user that an error has occurred. The values of the other
      variables (<code>L</code>, <code>Str</code>, etc.) are unchanged.
      </p>
    <p class="english">Commands 12 and 13 show that <code>P</code> is unbound because the
      previous command failed, and that <code>Descriptor</code> has not
      changed.
      </p>
    <p class="english">Commands 14 and 15 show a correct match where <code>P</code> and
      <code>Q</code> are bound.
      </p>
    <p class="english">Command 16 clears all bindings.
      </p>
    <p class="english">The next few commands assume that <code>test1:demo(X)</code> is
      defined in the following way:</p>
    <pre>
demo(X) ->
    put(aa, worked),
    X = 1,
    X + 10.    </pre>
    <p class="english">Commands 17 and 18 set and inspect the value of the item
      <code>aa</code> in the process dictionary.
      </p>
    <p class="english">Command 19 evaluates <code>test1:demo(1)</code>. The evaluation
      succeeds and the changes made in the process dictionary become
      visible to the shell. The new value of the dictionary item
      <code>aa</code> can be seen in command 20.
      </p>
    <p class="english">Commands 21 and 22 change the value of the dictionary item
      <code>aa</code> to <code>hello</code> and call <code>test1:demo(2)</code>. Evaluation
      fails and the changes made to the dictionary in
      <code>test1:demo(2)</code>, before the error occurred, are discarded.
      </p>
    <p class="english">Commands 23 and 24 show that <code>Z</code> was not bound and that the
      dictionary item <code>aa</code> has retained its original value.
      </p>
    <p class="english">Commands 25, 26 and 27 show the effect of evaluating
      <code>test1:demo(1)</code> in the background. In this case, the
      expression is evaluated in a newly spawned process. Any
      changes made in the process dictionary are local to the newly
      spawned process and therefore not visible to the shell.
      </p>
    <p class="english">Commands 28, 29 and 30 use the history facilities of the shell.
      </p>
    <p class="english">Command 29 is <code>e(28)</code>. This re-evaluates command
      28. Command 30 is <code>v(28)</code>. This uses the value (result) of
      command 28. In the cases of a pure function (a function
      with no side effects), the result is the same. For a function
      with side effects, the result can be different.
      </p>
    <p class="english">The next few commands show some record manipulation. It is 
      assumed that <code>ex.erl</code> defines a record like this:</p>
    <pre>
-record(rec, {a, b = val()}).

val() ->
    3.    </pre>
    <p class="english">Commands 31 and 32 compiles the file <code>ex.erl</code> and reads
      the record definitions in <code>ex.beam</code>. If the compiler did not
      output any record definitions on the BEAM file, <code>rr(ex)</code>
      tries to read record definitions from the source file instead.
      </p>
    <p class="english">Command 33 prints the definition of the record named
      <code>rec</code>. 
      </p>
    <p class="english">Command 34 tries to create a <code>rec</code> record, but fails
      since the function <code>val/0</code> is undefined. Command 35 shows
      the workaround: explicitly assign values to record fields that
      cannot otherwise be initialized.
      </p>
    <p class="english">Command 36 prints the newly created record using record
      definitions maintained by the shell.
      </p>
    <p class="english">Command 37 defines a record directly in the shell. The 
      definition replaces the one read from the file <code>ex.beam</code>.
      </p>
    <p class="english">Command 38 creates a record using the new definition, and
      prints the result.
      </p>
    <p class="english">Command 39 and 40 show that record definitions are updated
      as side effects. The evaluation of the command fails but
      the definition of <code>rec</code> has been carried out.
      </p>
    <p class="english">For the next command, it is assumed that <code>test1:loop(N)</code> is
      defined in the following way:</p>
    <pre>
loop(N) ->
    io:format("Hello Number: ~w~n", [N]), 
    loop(N+1).</pre>
    <p class="english">Command 41 evaluates <code>test1:loop(0)</code>, which puts the
      system into an infinite loop. At this point the user types
      <code>Control G</code>, which suspends output from the current process,
      which is stuck in a loop, and activates <code>JCL</code> mode. In <code>JCL</code>
      mode the user can start and stop jobs.
      </p>
    <p class="english">In this particular case, the <code>i</code> command ("interrupt") is
      used to terminate the looping program, and the <code>c</code> command
      is used to connect to the shell again. Since the process was
      running in the background before we killed it, there will be
      more printouts before the "<code>** exception exit: killed</code>"
      message is shown.
      </p>
    <p class="english">Command 42 creates an ETS table.</p>
    <p class="english">Command 43 tries to insert a tuple into the ETS table but the
      first argument (the table) is missing. The exception kills the
      evaluator process.</p>
    <p class="english">Command 44 corrects the mistake, but the ETS table has been
      destroyed since it was owned by the killed evaluator process.</p>
    <p class="english">Command 46 sets the exception handling of the evaluator process
      to <code>true</code>. The exception handling can also be set when
      starting Erlang, like this: <code>erl -stdlib shell_catch_exception
      true</code>.</p>
    <p class="english">Command 48 makes the same mistake as in command 43, but this time
      the evaluator process lives on. The single star at the beginning
      of the printout signals that the exception has been caught.</p>
    <p class="english">Command 49 successfully inserts the tuple into the ETS table.</p>
    <p class="english">The <code>halt()</code> command exits the Erlang runtime system.
      </p>
  </section>
  <section>
    <h4>JCL Mode</h4>
    <p class="english">When the shell starts, it starts a single evaluator
      process. This process, together with any local processes which
      it spawns, is referred to as a <code>job</code>. Only the current job,
      which is said to be <code>connected</code>, can perform operations
      with standard IO. All other jobs, which are said to be <code>detached</code>, are
      <code>blocked</code> if they attempt to use standard IO.
      </p>
    <p class="english">All jobs which do not use standard IO run in the normal way.
      </p>
    <p class="english">The shell escape key <em><code>^G</code></em> (Control G) detaches the current job 
      and activates <code>JCL</code> mode. The <code>JCL</code> mode prompt is <code>"-->"</code>. If <code>"?"</code> is entered at the prompt, the following help message is
      displayed:</p>
    <pre>
          --> ?
          c [nn]            - connect to job
          i [nn]            - interrupt job
          k [nn]            - kill job
          j                 - list all jobs
          s [shell]         - start local shell
          r [node [shell]]  - start remote shell
          q        - quit erlang
          ? | h             - this message    </pre>
    <p class="english">The <code>JCL</code> commands have the following meaning:</p>
    <div class="taglist">
      <dt>
        <code>c [nn]</code>
      </dt>
      <p class="english">
        <p class="english">Connects to job number <code><![CDATA[<nn>]]></code> or the current
          job. The standard shell is resumed. Operations which use
          standard IO by the current job will be interleaved with
          user inputs to the shell.
          </p>
      </p>
      <dt>
        <code>i [nn]</code>
      </dt>
      <p class="english">
        <p class="english">Stops the current evaluator process for job number
          <code>nn</code> or the current job, but does not kill the shell
          process. Accordingly, any variable bindings and the process dictionary
          will be preserved and the job can be connected again.
          This command can be used to interrupt an endless loop.
          </p>
      </p>
      <dt>
        <code>k [nn]</code>
      </dt>
      <p class="english">
        <p class="english">Kills job number <code>nn</code> or the current
          job. All spawned processes in the job are
          killed, provided they have not evaluated the
          <code>group_leader/1</code> BIF and are located on
          the local machine. Processes spawned on remote nodes will
          not be killed.
          </p>
      </p>
      <dt>
        <code>j</code>
      </dt>
      <p class="english">
        <p class="english">Lists all jobs. A list of all known jobs is
          printed. The current job name is prefixed with '*'.
          </p>
      </p>
      <dt>
        <code>s</code>
      </dt>
      <p class="english">
        <p class="english">Starts a new job. This will be assigned the new index
          <code>[nn]</code> which can be used in references.
          </p>
      </p>
      <dt>
        <code>s [shell]</code>
      </dt>
      <p class="english">
        <p class="english">Starts a new job. This will be assigned the new index
          <code>[nn]</code> which can be used in references.
	  If the optional argument <code>shell</code> is given, it is assumed
	  to be a module that implements an alternative shell.
          </p>
      </p>
      <dt>
        <code>r [node]</code>
      </dt>
      <p class="english">
        <p class="english">Starts a remote job on <code>node</code>. This is used in
          distributed Erlang to allow a shell running on one node to
          control a number of applications running on a network of
          nodes.
	  If the optional argument <code>shell</code> is given, it is assumed
	  to be a module that implements an alternative shell.
          </p>
      </p>
      <dt>
        <code>q</code>
      </dt>
      <p class="english">
        <p class="english">Quits Erlang. Note that this option is disabled if
          Erlang is started with the ignore break, <code>+Bi</code>, 
          system flag (which may be useful e.g. when running
          a restricted shell, see below).
          </p>
      </p>
      <dt>
        <code>?</code>
      </dt>
      <p class="english">
        <p class="english">Displays this message.</p>
      </p>
    </div>
    <p class="english">It is possible to alter the behavior of shell escape by means 
      of the STDLIB application variable <code>shell_esc</code>. The value of
      the variable can be either <code>jcl</code> (<code>erl -stdlib shell_esc jcl</code>) 
      or <code>abort</code> (<code>erl -stdlib shell_esc abort</code>). The 
      first option sets ^G to activate <code>JCL</code> mode (which is also 
      default behavior). The latter sets ^G to terminate the current 
      shell and start a new one. <code>JCL</code> mode cannot be invoked when 
      <code>shell_esc</code> is set to <code>abort</code>. </p>
    <p class="english">If you want an Erlang node to have a remote job active from the start 
      (rather than the default local job), you start Erlang with the 
      <code>-remsh</code> flag. Example: <code>erl -sname this_node -remsh other_node@other_host</code></p>
  </section>
  <section>
    <h4>Restricted Shell</h4>
    <p class="english">The shell may be started in a
      restricted mode. In this mode, the shell evaluates a function call
      only if allowed. This feature makes it possible to, for example,
      prevent a user from accidentally calling a function from the
      prompt that could harm a running system (useful in combination
      with the the system flag <em><code>+Bi</code></em>).</p>
    <p class="english">When the restricted shell evaluates an expression and
      encounters a function call or an operator application, 
      it calls a callback function (with
      information about the function call in question). This callback
      function returns <code>true</code> to let the shell go ahead with the
      evaluation, or <code>false</code> to abort it. There are two possible
      callback functions for the user to implement:</p>
    <p class="english">
      <em>
        <code>local_allowed(Func, ArgList, State) -> {true,NewState} | {false,NewState}</code>
      </em>
    </p>
    <p class="english">to determine if the call to the local function <code>Func</code>
      with arguments <code>ArgList</code> should be allowed.</p>
    <p class="english">
      <em>
        <code>non_local_allowed(FuncSpec, ArgList, State) -> {true,NewState} | {false,NewState} |  {{redirect,NewFuncSpec,NewArgList},NewState}</code>
      </em>
    </p>
    <p class="english">to determine if the call to non-local function
      <code>FuncSpec</code> (<code>{Module,Func}</code> or a fun) with arguments
      <code>ArgList</code> should be allowed. The return value 
      <code>{redirect,NewFuncSpec,NewArgList}</code> can be used to let 
      the shell evaluate some other function than the one specified by 
      <code>FuncSpec</code> and <code>ArgList</code>.</p>
    <p class="english">These callback functions are in fact called from local and
      non-local evaluation function handlers, described in the
      <a class="seealso" href="">erl_eval</a> 
      manual page. (Arguments in <code>ArgList</code> are evaluated before the
      callback functions are called.)</p>
    <p class="english">The <code>State</code> argument is a tuple
      <code>{ShellState,ExprState}</code>. The return value <code>NewState</code>
      has the same form. This may be used to carry a state between calls
      to the callback functions. Data saved in <code>ShellState</code> lives
      through an entire shell session. Data saved in <code>ExprState</code>
      lives only through the evaluation of the current expression.</p>
    <p class="english">There are two ways to start a restricted shell session:</p>
    <list type="bulleted">
      <p class="english">Use the STDLIB application variable <code>restricted_shell</code>
       and specify, as its value, the name of the callback
       module. Example (with callback functions implemented in
       callback_mod.erl): <code>$ erl -stdlib restricted_shell callback_mod</code></p>
      <p class="english">From a normal shell session, call function
      <code>shell:start_restricted/1</code>. This exits the current evaluator
       and starts a new one in restricted mode.</p>
    </list>
    <p class="english">
      <em>Notes:</em>
    </p>
    <list type="bulleted">
      <p class="english">When restricted shell mode is activated or
       deactivated, new jobs started on the node will run in restricted
       or normal mode respectively.</p>
      <p class="english">If restricted mode has been enabled on a
       particular node, remote shells connecting to this node will also
       run in restricted mode.</p>
      <p class="english">The callback functions cannot be used to allow or disallow
       execution of functions called from compiled code (only functions
       called from expressions entered at the shell prompt).</p>
    </list>
    <p class="english">Errors when loading the callback module is handled in different
      ways depending on how the restricted shell is activated:</p>
    <list type="bulleted">
      <p class="english">If the restricted shell is activated by setting the kernel
       variable during emulator startup and the callback module cannot be
       loaded, a default restricted shell allowing only the commands
      <code>q()</code> and <code>init:stop()</code> is used as fallback.</p>
      <p class="english">If the restricted shell is activated using
      <code>shell:start_restricted/1</code> and the callback module cannot be
       loaded, an error report is sent to the error logger and the call
       returns <code>{error,Reason}</code>.</p>
    </list>
  </section>
  <section>
    <h4>Prompting</h4>
    <p class="english">The default shell prompt function displays the name of the node
      (if the node can be part of a distributed system) and the
      current command number. The user can customize the prompt
      function by calling
      <code>shell:prompt_func/1</code> or by setting the application
      configuration parameter <code>shell_prompt_func</code> for the
      application STDLIB.</p>
    <p class="english">A customized prompt function is stated as a tuple
      <code>{Mod,&nbsp;Func}</code>. The function is called as
      <code>Mod:Func(L)</code>, where <code>L</code> is a list of key-value pairs
      created by the shell. Currently there is only one pair:
      <code>{history, N}</code>, where N is the current command number. The
      function should return a list of characters or an atom. This
      constraint is due to the Erlang I/O-protocol. Unicode characters
      beyond codepoint 255 are allowed in the list. Note
      that in restricted mode the call <code>Mod:Func(L)</code> must be
      allowed or the default shell prompt function will be called.</p>
  </section>
  <div class="functions">
    <h4>Functions:</h4>
    <hr/>
    <div class="function">
      <h3 arity="1" id="history/1" name="history">history(N) -> non_neg_integer()</h3>
      <div class="type_desc">      N = non_neg_integer()</div>
      <div class="discription">
        <p class="english">Sets the number of previous commands to keep in the
          history list to <code><anno>N</anno></code>. The previous number is returned.
          The default number is 20.</p>
      </div>
    </div>
    <div class="function">
      <h3 arity="1" id="results/1" name="results">results(N) -> non_neg_integer()</h3>
      <div class="type_desc">      N = non_neg_integer()</div>
      <div class="discription">
        <p class="english">Sets the number of results from previous commands to keep in
          the history list to <code><anno>N</anno></code>. The previous number is returned.
          The default number is 20.</p>
      </div>
    </div>
    <div class="function">
      <h3 id="catch_exception/1">catch_exception(Bool) -> Bool</h3>
      <type>
        <div class="type_desc">Bool = boolean()</div>
      </type>
      <div class="discription">
        <p class="english">Sets the exception handling of the evaluator process. The
          previous exception handling is returned. The default
          (<code>false</code>) is to kill the evaluator process when an
          exception occurs, which causes the shell to create a new
          evaluator process. When the exception handling is set to
          <code>true</code> the evaluator process lives on which means that
          for instance ports and ETS tables as well as processes
          linked to the evaluator process survive the exception.</p>
      </div>
    </div>
    <div class="function">
      <h3 arity="1" id="prompt_func/1" name="prompt_func">prompt_func(PromptFunc) -> PromptFunc</h3>
      <div class="type_desc">      PromptFunc = 'default' | {module(),atom()}</div>
      <div class="discription">
        <p class="english">Sets the shell prompt function to <code>PromptFunc</code>. The
          previous prompt function is returned.</p>
      </div>
    </div>
    <div class="function">
      <h3 arity="1" id="start_restricted/1" name="start_restricted">start_restricted(Module) -> {'error', Reason}</h3>
      <div class="type_desc">      Module = module(),<br/>      Reason = code:load_error_rsn()</div>
      <div class="discription">
        <p class="english">Exits a normal shell and starts a restricted
          shell. <code><anno>Module</anno></code> specifies the callback module for the
          functions <code>local_allowed/3</code> and <code>non_local_allowed/3</code>.
          The function is meant to be called from the shell.</p>
        <p class="english">If the callback module cannot be loaded, an error tuple is
          returned. The <code><anno>Reason</anno></code> in the error tuple is the one
          returned by the code loader when trying to load the code of the callback
          module.</p>
      </div>
    </div>
    <div class="function">
      <h3 arity="0" id="stop_restricted/0" name="stop_restricted">stop_restricted() -> no_return()</h3>
      <div class="discription">
        <p class="english">Exits a restricted shell and starts a normal shell. The function
          is meant to be called from the shell.</p>
      </div>
    </div>
  </div>
</div>

    </div>
    <script type="text/javascript">
      var CURRENT_ROOT = "../";
    </script>
    <script type="text/javascript" src="../js/jquery.js"></script>
    <script type="text/javascript" src="../js/erldocs_index.js"></script>
    <script type="text/javascript" src="../js/erldocs.js"></script>

  </body>
</html>
